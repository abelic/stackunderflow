"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const syntax_1 = require("@glimmer/syntax");
// BuildAttr
function buildAttr(name, content) {
    if (content === undefined) {
        return null;
    }
    else if (typeof content === 'string') {
        return syntax_1.builders.attr(name, syntax_1.builders.text(content));
    }
    else if (content.type === 'PathExpression') {
        return syntax_1.builders.attr(name, syntax_1.builders.mustache(content));
    }
    else if (content.type === 'SubExpression') {
        return syntax_1.builders.attr(name, syntax_1.builders.mustache(content.path, content.params, content.hash));
    }
    else if (content.type === 'StringLiteral') {
        return syntax_1.builders.attr(name, syntax_1.builders.text(content.value));
    }
    else if (content.type === 'BooleanLiteral') {
        return content.value ? syntax_1.builders.attr(name, syntax_1.builders.text('')) : null;
    }
    else if (content.type === 'NumberLiteral') {
        return syntax_1.builders.attr(name, syntax_1.builders.text(String(content.value)));
    }
    else if (content.type === 'NullLiteral' || content.type === 'UndefinedLiteral') {
        return null;
    }
    else if (content.type === 'ConcatStatement') {
        if (content.parts.length === 1) {
            content.parts[0];
            return buildAttr(name, content.parts[0]);
        }
        return syntax_1.builders.attr(name, content);
    }
    else {
        return syntax_1.builders.attr(name, content);
    }
}
exports.buildAttr = buildAttr;
// appendToAttrContent
function appendToAttrContent(val, content = syntax_1.builders.text(''), opts = { prependSpace: true }) {
    if (typeof content === 'string') {
        content = syntax_1.builders.text(content);
    }
    if (val === undefined || val === null) {
        return content;
    }
    if (typeof val === 'string' || typeof val === 'number') {
        return appendLiteralToContent(String(val), content, opts);
    }
    switch (val.type) {
        case 'StringLiteral':
            content = appendLiteralToContent(val.value, content, opts);
            break;
        case 'NumberLiteral':
            content = appendLiteralToContent(String(val.value), content, opts);
            break;
        case 'PathExpression':
            content = appendPathToContent(val, content, opts);
            break;
        case 'SubExpression':
            content = appendSubExpressionToContent(val, content, opts);
            break;
        case 'MustacheStatement':
            content = appendMustacheToContent(val, content, opts);
            break;
        case 'ConcatStatement':
            val.parts.forEach((part, i) => {
                content = appendToAttrContent(part, content, i === 0 ? opts : { prependSpace: false });
            });
            break;
        case 'TextNode':
            content = appendTextNodeToContent(val, content, opts);
            break;
    }
    return content;
}
exports.appendToAttrContent = appendToAttrContent;
function appendLiteralToContent(str, content, opts) {
    if (content.type === 'TextNode') {
        if (content.chars === '') {
            content.chars = str;
        }
        else {
            content.chars = [content.chars, str].join(opts.prependSpace ? ' ' : '');
        }
    }
    else if (content.type === 'ConcatStatement') {
        let lastPart = content.parts[content.parts.length - 1];
        if (lastPart.type === 'TextNode') {
            lastPart.chars = [lastPart.chars, str].join(opts.prependSpace ? ' ' : '');
        }
        else {
            content.parts.push(syntax_1.builders.text(opts.prependSpace ? ` ${str}` : str));
        }
    }
    else {
        throw new Error('Unexpected content type');
    }
    return content;
}
function appendTextNodeToContent(textNode, content, opts) {
    return appendLiteralToContent(textNode.chars, content, opts);
}
function appendMustacheToContent(mustache, content, opts) {
    if (content.type === 'TextNode') {
        if (content.chars !== '') {
            if (opts.prependSpace) {
                content.chars += ' ';
            }
            return syntax_1.builders.concat([content, mustache]);
        }
        else {
            return syntax_1.builders.concat([mustache]);
        }
    }
    else if (content.type === 'ConcatStatement') {
        let lastPart = content.parts[content.parts.length - 1];
        if (opts.prependSpace) {
            if (lastPart.type === 'TextNode') {
                lastPart.chars = `${lastPart.chars} `;
            }
            else {
                content.parts.push(syntax_1.builders.text(' '));
            }
        }
        content.parts.push(mustache);
        return content;
    }
    else {
        throw new Error('Unexpected content type');
    }
}
function appendPathToContent(pathExp, content, opts) {
    return appendMustacheToContent(syntax_1.builders.mustache(pathExp), content, opts);
}
function appendSubExpressionToContent(sexpr, content, opts) {
    return appendMustacheToContent(syntax_1.builders.mustache(sexpr.path, sexpr.params, sexpr.hash), content, opts);
}
// buildAttrContent
function buildAttrContent(parts) {
    let content = undefined;
    for (let i = 0; i < parts.length; i++) {
        content = appendToAttrContent(parts[i], content, { prependSpace: false });
    }
    return content;
}
exports.buildAttrContent = buildAttrContent;
