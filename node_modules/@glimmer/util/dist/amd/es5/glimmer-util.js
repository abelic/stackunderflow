define('@glimmer/util', ['exports'], function (exports) { 'use strict';

function unwrap(val) {
    if (val === null || val === undefined) throw new Error("Expected value to be present");
    return val;
}
function expect(val, message) {
    if (val === null || val === undefined) throw new Error(message);
    return val;
}
function unreachable() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "unreachable";

    return new Error(message);
}
function typePos(lastOperand) {
    return lastOperand - 4;
}

// import Logger from './logger';
// let alreadyWarned = false;
function debugAssert(test, msg) {
    // if (!alreadyWarned) {
    //   alreadyWarned = true;
    //   Logger.warn("Don't leave debug assertions on in public builds");
    // }
    if (!test) {
        throw new Error(msg || "assertion failure");
    }
}

var objKeys = Object.keys;

function assign(obj) {
    for (var i = 1; i < arguments.length; i++) {
        var assignment = arguments[i];
        if (assignment === null || typeof assignment !== 'object') continue;
        var keys = objKeys(assignment);
        for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            obj[key] = assignment[key];
        }
    }
    return obj;
}
function fillNulls(count) {
    var arr = new Array(count);
    for (var i = 0; i < count; i++) {
        arr[i] = null;
    }
    return arr;
}

var GUID = 0;
function initializeGuid(object) {
    return object._guid = ++GUID;
}
function ensureGuid(object) {
    return object._guid || initializeGuid(object);
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var proto = Object.create(null, {
    // without this, we will always still end up with (new
    // EmptyObject()).constructor === Object
    constructor: {
        value: undefined,
        enumerable: false,
        writable: true
    }
});
function EmptyObject() {}
EmptyObject.prototype = proto;
function dict() {
    // let d = Object.create(null);
    // d.x = 1;
    // delete d.x;
    // return d;
    return new EmptyObject();
}
var DictSet = function () {
    function DictSet() {
        _classCallCheck(this, DictSet);

        this.dict = dict();
    }

    DictSet.prototype.add = function add(obj) {
        if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;
        return this;
    };

    DictSet.prototype.delete = function _delete(obj) {
        if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
    };

    return DictSet;
}();
var Stack = function () {
    function Stack() {
        _classCallCheck(this, Stack);

        this.stack = [];
        this.current = null;
    }

    Stack.prototype.push = function push(item) {
        this.current = item;
        this.stack.push(item);
    };

    Stack.prototype.pop = function pop() {
        var item = this.stack.pop();
        var len = this.stack.length;
        this.current = len === 0 ? null : this.stack[len - 1];
        return item === undefined ? null : item;
    };

    Stack.prototype.isEmpty = function isEmpty() {
        return this.stack.length === 0;
    };

    return Stack;
}();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ListNode = function ListNode(value) {
    _classCallCheck$1(this, ListNode);

    this.next = null;
    this.prev = null;
    this.value = value;
};
var LinkedList = function () {
    function LinkedList() {
        _classCallCheck$1(this, LinkedList);

        this.clear();
    }

    LinkedList.prototype.head = function head() {
        return this._head;
    };

    LinkedList.prototype.tail = function tail() {
        return this._tail;
    };

    LinkedList.prototype.clear = function clear() {
        this._head = this._tail = null;
    };

    LinkedList.prototype.toArray = function toArray() {
        var out = [];
        this.forEachNode(function (n) {
            return out.push(n);
        });
        return out;
    };

    LinkedList.prototype.nextNode = function nextNode(node) {
        return node.next;
    };

    LinkedList.prototype.forEachNode = function forEachNode(callback) {
        var node = this._head;
        while (node !== null) {
            callback(node);
            node = node.next;
        }
    };

    LinkedList.prototype.insertBefore = function insertBefore(node) {
        var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (reference === null) return this.append(node);
        if (reference.prev) reference.prev.next = node;else this._head = node;
        node.prev = reference.prev;
        node.next = reference;
        reference.prev = node;
        return node;
    };

    LinkedList.prototype.append = function append(node) {
        var tail = this._tail;
        if (tail) {
            tail.next = node;
            node.prev = tail;
            node.next = null;
        } else {
            this._head = node;
        }
        return this._tail = node;
    };

    LinkedList.prototype.remove = function remove(node) {
        if (node.prev) node.prev.next = node.next;else this._head = node.next;
        if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
        return node;
    };

    return LinkedList;
}();
var ListSlice = function () {
    function ListSlice(head, tail) {
        _classCallCheck$1(this, ListSlice);

        this._head = head;
        this._tail = tail;
    }

    ListSlice.prototype.forEachNode = function forEachNode(callback) {
        var node = this._head;
        while (node !== null) {
            callback(node);
            node = this.nextNode(node);
        }
    };

    ListSlice.prototype.head = function head() {
        return this._head;
    };

    ListSlice.prototype.tail = function tail() {
        return this._tail;
    };

    ListSlice.prototype.toArray = function toArray() {
        var out = [];
        this.forEachNode(function (n) {
            return out.push(n);
        });
        return out;
    };

    ListSlice.prototype.nextNode = function nextNode(node) {
        if (node === this._tail) return null;
        return node.next;
    };

    return ListSlice;
}();
var EMPTY_SLICE = new ListSlice(null, null);

var HAS_NATIVE_WEAKMAP = function () {
    // detect if `WeakMap` is even present
    var hasWeakMap = typeof WeakMap === 'function';
    if (!hasWeakMap) {
        return false;
    }
    var instance = new WeakMap();
    // use `Object`'s `.toString` directly to prevent us from detecting
    // polyfills as native weakmaps
    return Object.prototype.toString.call(instance) === '[object WeakMap]';
}();

var HAS_TYPED_ARRAYS = typeof Uint32Array !== 'undefined';
var A = void 0;
if (HAS_TYPED_ARRAYS) {
    A = Uint32Array;
} else {
    A = Array;
}
var A$1 = A;
var EMPTY_ARRAY = HAS_NATIVE_WEAKMAP ? Object.freeze([]) : [];

exports.assert = debugAssert;
exports.assign = assign;
exports.fillNulls = fillNulls;
exports.ensureGuid = ensureGuid;
exports.initializeGuid = initializeGuid;
exports.Stack = Stack;
exports.DictSet = DictSet;
exports.dict = dict;
exports.EMPTY_SLICE = EMPTY_SLICE;
exports.LinkedList = LinkedList;
exports.ListNode = ListNode;
exports.ListSlice = ListSlice;
exports.A = A$1;
exports.EMPTY_ARRAY = EMPTY_ARRAY;
exports.HAS_NATIVE_WEAKMAP = HAS_NATIVE_WEAKMAP;
exports.unwrap = unwrap;
exports.expect = expect;
exports.unreachable = unreachable;
exports.typePos = typePos;

Object.defineProperty(exports, '__esModule', { value: true });

});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci11dGlsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9wbGF0Zm9ybS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2Fzc2VydC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL29iamVjdC11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2d1aWQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9jb2xsZWN0aW9ucy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2xpc3QtdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi93ZWFrbWFwLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvYXJyYXktdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHR5cGUgT3BhcXVlID0ge30gfCB2b2lkIHwgbnVsbCB8IHVuZGVmaW5lZDtcbmV4cG9ydCB0eXBlIE9wdGlvbjxUPiA9IFQgfCBudWxsO1xuZXhwb3J0IHR5cGUgTWF5YmU8VD4gPSBPcHRpb248VD4gfCB1bmRlZmluZWQgfCB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwPFQ+KHZhbDogTWF5YmU8VD4pOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBwcmVzZW50YCk7XG4gIHJldHVybiB2YWwgYXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGVjdDxUPih2YWw6IE1heWJlPFQ+LCBtZXNzYWdlOiBzdHJpbmcpOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gdmFsIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnJlYWNoYWJsZShtZXNzYWdlID0gXCJ1bnJlYWNoYWJsZVwiKTogRXJyb3Ige1xuICByZXR1cm4gbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZVBvcyhsYXN0T3BlcmFuZDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIGxhc3RPcGVyYW5kIC0gNDtcbn1cbiIsIi8vIGltcG9ydCBMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuXG4vLyBsZXQgYWxyZWFkeVdhcm5lZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVidWdBc3NlcnQodGVzdDogYW55LCBtc2c6IHN0cmluZykge1xuICAvLyBpZiAoIWFscmVhZHlXYXJuZWQpIHtcbiAgLy8gICBhbHJlYWR5V2FybmVkID0gdHJ1ZTtcbiAgLy8gICBMb2dnZXIud2FybihcIkRvbid0IGxlYXZlIGRlYnVnIGFzc2VydGlvbnMgb24gaW4gcHVibGljIGJ1aWxkc1wiKTtcbiAgLy8gfVxuXG4gIGlmICghdGVzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgXCJhc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvZEFzc2VydCgpIHt9XG5cbmV4cG9ydCBkZWZhdWx0IGRlYnVnQXNzZXJ0O1xuIiwiY29uc3QgeyBrZXlzOiBvYmpLZXlzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVT4ob2JqOiBULCBhc3NpZ25tZW50czogVSk6IFQgJiBVO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWPihvYmo6IFQsIGE6IFUsIGI6IFYpOiBUICYgVSAmIFY7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFc+KG9iajogVCwgYTogVSwgYjogViwgYzogVyk6IFQgJiBVICYgViAmIFc7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFg+KG9iajogVCwgYTogVSwgYjogViwgYzogVywgZDogWCk6IFQgJiBVICYgViAmIFcgJiBYO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWLCBXLCBYLCBZPihvYmo6IFQsIGE6IFUsIGI6IFYsIGM6IFcsIGQ6IFgsIGU6IFkpOiBUICYgVSAmIFYgJiBXICYgWCAmIFk7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFgsIFksIFo+KG9iajogVCwgYTogVSwgYjogViwgYzogVywgZDogWCwgZTogWSwgZjogWik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldDogYW55LCAuLi5hcmdzOiBhbnlbXSk6IGFueTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqOiBhbnkpIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYXNzaWdubWVudCA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoYXNzaWdubWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgYXNzaWdubWVudCAhPT0gJ29iamVjdCcpIGNvbnRpbnVlO1xuICAgIGxldCBrZXlzID0gb2JqS2V5cyhhc3NpZ25tZW50KTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2pdO1xuICAgICAgb2JqW2tleV0gPSBhc3NpZ25tZW50W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsTnVsbHM8VD4oY291bnQ6IG51bWJlcik6IFRbXSB7XG4gIGxldCBhcnIgPSBuZXcgQXJyYXkoY291bnQpO1xuXG4gIGZvciAobGV0IGk9MDsgaTxjb3VudDsgaSsrKSB7XG4gICAgYXJyW2ldID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59IiwibGV0IEdVSUQgPSAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhc0d1aWQge1xuICBfZ3VpZDogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUd1aWQob2JqZWN0OiBIYXNHdWlkKTogbnVtYmVyIHtcbiAgcmV0dXJuIChvYmplY3QuX2d1aWQgPSArK0dVSUQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlR3VpZChvYmplY3Q6IEhhc0d1aWQpOiBudW1iZXIge1xuICByZXR1cm4gb2JqZWN0Ll9ndWlkIHx8IGluaXRpYWxpemVHdWlkKG9iamVjdCk7XG59IiwiaW1wb3J0IHsgSGFzR3VpZCwgZW5zdXJlR3VpZCB9IGZyb20gJy4vZ3VpZCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBEaWN0PFQ+IHtcbiAgW2luZGV4OiBzdHJpbmddOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldDxUPiB7XG4gIGFkZCh2YWx1ZTogVCk6IFNldDxUPjtcbiAgZGVsZXRlKHZhbHVlOiBUKTogdm9pZDtcbn1cblxubGV0IHByb3RvID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gIC8vIHdpdGhvdXQgdGhpcywgd2Ugd2lsbCBhbHdheXMgc3RpbGwgZW5kIHVwIHdpdGggKG5ld1xuICAvLyBFbXB0eU9iamVjdCgpKS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gRW1wdHlPYmplY3QoKSB7fVxuRW1wdHlPYmplY3QucHJvdG90eXBlID0gcHJvdG87XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWN0PFQ+KCk6IERpY3Q8VD4ge1xuICAvLyBsZXQgZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGQueCA9IDE7XG4gIC8vIGRlbGV0ZSBkLng7XG4gIC8vIHJldHVybiBkO1xuICByZXR1cm4gbmV3IChFbXB0eU9iamVjdCBhcyBhbnkpKCk7XG59XG5cbmV4cG9ydCB0eXBlIFNldE1lbWJlciA9IEhhc0d1aWQgfCBzdHJpbmc7XG5cbmV4cG9ydCBjbGFzcyBEaWN0U2V0PFQgZXh0ZW5kcyBTZXRNZW1iZXI+IGltcGxlbWVudHMgU2V0PFQ+IHtcbiAgcHJpdmF0ZSBkaWN0OiBEaWN0PFQ+O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGljdCA9IGRpY3Q8VD4oKTtcbiAgfVxuXG4gIGFkZChvYmo6IFQpOiBTZXQ8VD4ge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgdGhpcy5kaWN0Wzxhbnk+b2JqXSA9IG9iajtcbiAgICBlbHNlIHRoaXMuZGljdFtlbnN1cmVHdWlkKDxhbnk+b2JqKV0gPSBvYmo7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWxldGUob2JqOiBUKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSBkZWxldGUgdGhpcy5kaWN0Wzxhbnk+b2JqXTtcbiAgICBlbHNlIGlmICgob2JqIGFzIGFueSkuX2d1aWQpIGRlbGV0ZSB0aGlzLmRpY3RbKG9iaiBhcyBhbnkpLl9ndWlkXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3RhY2s8VD4ge1xuICBwcml2YXRlIHN0YWNrOiBUW10gPSBbXTtcbiAgcHVibGljIGN1cnJlbnQ6IE9wdGlvbjxUPiA9IG51bGw7XG5cbiAgcHVzaChpdGVtOiBUKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gaXRlbTtcbiAgICB0aGlzLnN0YWNrLnB1c2goaXRlbSk7XG4gIH1cblxuICBwb3AoKTogT3B0aW9uPFQ+IHtcbiAgICBsZXQgaXRlbSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHRoaXMuY3VycmVudCA9IGxlbiA9PT0gMCA/IG51bGwgOiB0aGlzLnN0YWNrW2xlbiAtIDFdO1xuXG4gICAgcmV0dXJuIGl0ZW0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBpdGVtO1xuICB9XG5cbiAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGggPT09IDA7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJy4vcGxhdGZvcm0tdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtlZExpc3ROb2RlIHtcbiAgbmV4dDogT3B0aW9uPExpbmtlZExpc3ROb2RlPjtcbiAgcHJldjogT3B0aW9uPExpbmtlZExpc3ROb2RlPjtcbn1cblxuZXhwb3J0IGNsYXNzIExpc3ROb2RlPFQ+IGltcGxlbWVudHMgTGlua2VkTGlzdE5vZGUge1xuICBwdWJsaWMgbmV4dDogT3B0aW9uPExpc3ROb2RlPFQ+PiA9IG51bGw7XG4gIHB1YmxpYyBwcmV2OiBPcHRpb248TGlzdE5vZGU8VD4+ID0gbnVsbDtcbiAgcHVibGljIHZhbHVlOiBUO1xuXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBUKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59XG5cbi8vIHdlIGFyZSB1bmFibGUgdG8gZXhwcmVzcyB0aGUgY29uc3RyYWludCB0aGF0IFQncyAucHJldiBhbmQgLm5leHQgYXJlXG4vLyB0aGVtc2VsdmVzIFQuIEhvd2V2ZXIsIGl0IHdpbGwgYWx3YXlzIGJlIHRydWUsIHNvIHRydXN0IHVzLlxudHlwZSB0cnVzdCA9IGFueTtcblxuZXhwb3J0IGNsYXNzIExpbmtlZExpc3Q8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiBpbXBsZW1lbnRzIFNsaWNlPFQ+IHtcblxuICBwcml2YXRlIF9oZWFkOiBPcHRpb248VD47XG4gIHByaXZhdGUgX3RhaWw6IE9wdGlvbjxUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cblxuICBoZWFkKCk6IE9wdGlvbjxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQ7XG4gIH1cblxuICB0YWlsKCk6IE9wdGlvbjxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX3RhaWw7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IG51bGw7XG4gIH1cblxuICB0b0FycmF5KCk6IFRbXSB7XG4gICAgbGV0IG91dDogVFtdID0gW107XG4gICAgdGhpcy5mb3JFYWNoTm9kZShuID0+IG91dC5wdXNoKG4pKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgbmV4dE5vZGUobm9kZTogVCk6IFQge1xuICAgIHJldHVybiA8dHJ1c3Q+bm9kZS5uZXh0O1xuICB9XG5cbiAgZm9yRWFjaE5vZGUoY2FsbGJhY2s6IChub2RlOiBUKSA9PiB2b2lkKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLl9oZWFkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKDx0cnVzdD5ub2RlKTtcbiAgICAgIG5vZGUgPSA8dHJ1c3Q+bm9kZS5uZXh0O1xuICAgIH1cbiAgfVxuXG4gIGluc2VydEJlZm9yZShub2RlOiBULCByZWZlcmVuY2U6IE9wdGlvbjxUPiA9IG51bGwpOiBUIHtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSByZXR1cm4gdGhpcy5hcHBlbmQobm9kZSk7XG5cbiAgICBpZiAocmVmZXJlbmNlLnByZXYpIHJlZmVyZW5jZS5wcmV2Lm5leHQgPSBub2RlO1xuICAgIGVsc2UgdGhpcy5faGVhZCA9IG5vZGU7XG5cbiAgICBub2RlLnByZXYgPSByZWZlcmVuY2UucHJldjtcbiAgICBub2RlLm5leHQgPSByZWZlcmVuY2U7XG4gICAgcmVmZXJlbmNlLnByZXYgPSBub2RlO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBhcHBlbmQobm9kZTogVCk6IFQge1xuICAgIGxldCB0YWlsID0gdGhpcy5fdGFpbDtcblxuICAgIGlmICh0YWlsKSB7XG4gICAgICB0YWlsLm5leHQgPSBub2RlO1xuICAgICAgbm9kZS5wcmV2ID0gdGFpbDtcbiAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hlYWQgPSBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fdGFpbCA9IG5vZGUpO1xuICB9XG5cbiAgcmVtb3ZlKG5vZGU6IFQpOiBUIHtcbiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICBlbHNlIHRoaXMuX2hlYWQgPSA8dHJ1c3Q+bm9kZS5uZXh0O1xuXG4gICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XG4gICAgZWxzZSB0aGlzLl90YWlsID0gPHRydXN0Pm5vZGUucHJldjtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2U8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiB7XG4gIGhlYWQoKTogT3B0aW9uPFQ+O1xuICB0YWlsKCk6IE9wdGlvbjxUPjtcbiAgbmV4dE5vZGUobm9kZTogVCk6IE9wdGlvbjxUPjtcbiAgZm9yRWFjaE5vZGUoY2FsbGJhY2s6IChub2RlOiBUKSA9PiB2b2lkKTogdm9pZDtcbiAgdG9BcnJheSgpOiBUW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xvbmVhYmxlTGlzdE5vZGUgZXh0ZW5kcyBMaW5rZWRMaXN0Tm9kZSB7XG4gIGNsb25lKCk6IHRoaXM7XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0U2xpY2U8VCBleHRlbmRzIExpbmtlZExpc3ROb2RlPiBpbXBsZW1lbnRzIFNsaWNlPFQ+IHtcbiAgcHJpdmF0ZSBfaGVhZDogT3B0aW9uPFQ+O1xuICBwcml2YXRlIF90YWlsOiBPcHRpb248VD47XG5cbiAgY29uc3RydWN0b3IoaGVhZDogT3B0aW9uPFQ+LCB0YWlsOiBPcHRpb248VD4pIHtcbiAgICB0aGlzLl9oZWFkID0gaGVhZDtcbiAgICB0aGlzLl90YWlsID0gdGFpbDtcbiAgfVxuXG4gIGZvckVhY2hOb2RlKGNhbGxiYWNrOiAobm9kZTogVCkgPT4gdm9pZCkge1xuICAgIGxldCBub2RlID0gdGhpcy5faGVhZDtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICAgIG5vZGUgPSB0aGlzLm5leHROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGhlYWQoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5faGVhZDtcbiAgfVxuXG4gIHRhaWwoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdGFpbDtcbiAgfVxuXG4gIHRvQXJyYXkoKTogVFtdIHtcbiAgICBsZXQgb3V0OiBUW10gPSBbXTtcbiAgICB0aGlzLmZvckVhY2hOb2RlKG4gPT4gb3V0LnB1c2gobikpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBuZXh0Tm9kZShub2RlOiBUKTogT3B0aW9uPFQ+IHtcbiAgICBpZiAobm9kZSA9PT0gdGhpcy5fdGFpbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIG5vZGUubmV4dCBhcyBUO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TTElDRSA9IG5ldyBMaXN0U2xpY2UobnVsbCwgbnVsbCk7XG4iLCJleHBvcnQgY29uc3QgSEFTX05BVElWRV9XRUFLTUFQID0gKGZ1bmN0aW9uKCkge1xuICAvLyBkZXRlY3QgaWYgYFdlYWtNYXBgIGlzIGV2ZW4gcHJlc2VudFxuICBsZXQgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIWhhc1dlYWtNYXApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGV0IGluc3RhbmNlID0gbmV3IFdlYWtNYXAoKTtcbiAgLy8gdXNlIGBPYmplY3RgJ3MgYC50b1N0cmluZ2AgZGlyZWN0bHkgdG8gcHJldmVudCB1cyBmcm9tIGRldGVjdGluZ1xuICAvLyBwb2x5ZmlsbHMgYXMgbmF0aXZlIHdlYWttYXBzXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5zdGFuY2UpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59KSgpO1xuIiwiaW1wb3J0IHsgSEFTX05BVElWRV9XRUFLTUFQIH0gZnJvbSAnLi93ZWFrbWFwJztcblxuY29uc3QgSEFTX1RZUEVEX0FSUkFZUyA9IHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmxldCBBO1xuXG5pZiAoSEFTX1RZUEVEX0FSUkFZUykge1xuICBBID0gVWludDMyQXJyYXk7XG59IGVsc2Uge1xuICBBID0gQXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEE7XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9BUlJBWTogYW55W10gPSAoSEFTX05BVElWRV9XRUFLTUFQID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXSkgYXMgYW55O1xuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O2dCQUkwQixLQUN4QjtRQUFJLFFBQVEsUUFBUSxRQUFRLFdBQVcsTUFBTSxJQUFJO1dBQzFDOztBQUdULGdCQUEwQixLQUFlLFNBQ3ZDO1FBQUksUUFBUSxRQUFRLFFBQVEsV0FBVyxNQUFNLElBQUksTUFBTTtXQUNoRDs7QUFHVDtRQUE0Qiw4RUFBVTs7V0FDN0IsSUFBSSxNQUFNOztBQUduQixpQkFBd0IsYUFDdEI7V0FBTyxjQUFjOzs7QUNuQnZCOztBQUlBLHFCQUE0QixNQUFXLEtBQ3JDOzs7OztRQUtJLENBQUMsTUFBTTtjQUNILElBQUksTUFBTSxPQUFPOztDQUkzQixBQUVBOztJQ2pCYyxVQUFZLE9BQWxCOztBQVNSLGdCQUF1QixLQUNyQjtTQUFLLElBQUksSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLEtBQUs7WUFDckMsYUFBYSxVQUFVO1lBQ3ZCLGVBQWUsUUFBUSxPQUFPLGVBQWUsVUFBVTtZQUN2RCxPQUFPLFFBQVE7YUFDZCxJQUFJLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFLO2dCQUNoQyxNQUFNLEtBQUs7Z0JBQ1gsT0FBTyxXQUFXOzs7V0FHbkI7O0FBR1QsbUJBQTZCLE9BQzNCO1FBQUksTUFBTSxJQUFJLE1BQU07U0FFZixJQUFJLElBQUUsR0FBRyxJQUFFLE9BQU8sS0FBSztZQUN0QixLQUFLOztXQUdKOzs7QUM3QlQsSUFBSSxPQUFPO0FBTVgsd0JBQStCLFFBQzdCO1dBQVEsT0FBTyxRQUFRLEVBQUU7O0FBRzNCLG9CQUEyQixRQUN6QjtXQUFPLE9BQU8sU0FBUyxlQUFlOzs7OztBQ1h4QyxBQVlBLElBQUksZUFBZSxPQUFPOzs7O2VBSWY7b0JBQ0s7a0JBTEo7OztBQVVaLHVCQUF3QjtBQUN4QixZQUFZLFlBQVk7QUFFeEIsZ0JBQ0U7Ozs7O1dBSU8sSUFBSzs7QUFLZCxJQUdFOzs7O2FBQ08sT0FBTzs7O3lDQUdWLEtBQ0Y7WUFBSSxPQUFPLFFBQVEsVUFBVSxLQUFLLEtBQVUsT0FBTyxTQUM5QyxLQUFLLEtBQUssV0FBZ0IsUUFBUTtlQUNoQzs7O2dEQUdGLEtBQ0w7WUFBSSxPQUFPLFFBQVEsVUFBVSxPQUFPLEtBQUssS0FBVSxVQUM5QyxJQUFLLElBQVksT0FBTyxPQUFPLEtBQUssS0FBTSxJQUFZOzs7OztBQUkvRCxJQUFBOzs7O2FBQ2UsUUFBUTthQUNQLFVBQWM7Ozt5Q0FFdkIsTUFDSDthQUFLLFVBQVU7YUFDVixNQUFNLEtBQUs7Ozt5Q0FJaEI7WUFBSSxPQUFPLEtBQUssTUFBTTtZQUNsQixNQUFNLEtBQUssTUFBTTthQUNoQixVQUFVLFFBQVEsSUFBSSxPQUFPLEtBQUssTUFBTSxNQUFNO2VBRTVDLFNBQVMsWUFBWSxPQUFPOzs7aURBSW5DO2VBQU8sS0FBSyxNQUFNLFdBQVc7Ozs7Ozs7O0FDakVqQyxJQUtFLDZCQUFZOzs7U0FKRCxPQUF3QjtTQUN4QixPQUF3QjtTQUk1QixRQUFROztBQVFqQixJQUtFOzs7O2FBQ087OztnREFJTDtlQUFPLEtBQUs7OztnREFJWjtlQUFPLEtBQUs7OztrREFJWjthQUFLLFFBQVEsS0FBSyxRQUFROzs7c0RBSTFCO1lBQUksTUFBVzthQUNWO21CQUFpQixJQUFJLEtBQUs7O2VBQ3hCOzs7c0RBR0EsTUFDUDtlQUFjLEtBQUs7Ozs0REFHVCxVQUNWO1lBQUksT0FBTyxLQUFLO2VBRVQsU0FBUyxNQUFNO3FCQUNKO21CQUNGLEtBQUs7Ozs7OERBSVY7WUFBUyxnRkFBdUI7O1lBQ3ZDLGNBQWMsTUFBTSxPQUFPLEtBQUssT0FBTztZQUV2QyxVQUFVLE1BQU0sVUFBVSxLQUFLLE9BQU8sVUFDckMsS0FBSyxRQUFRO2FBRWIsT0FBTyxVQUFVO2FBQ2pCLE9BQU87a0JBQ0YsT0FBTztlQUVWOzs7a0RBR0YsTUFDTDtZQUFJLE9BQU8sS0FBSztZQUVaLE1BQU07aUJBQ0gsT0FBTztpQkFDUCxPQUFPO2lCQUNQLE9BQU87ZUFDUDtpQkFDQSxRQUFROztlQUdQLEtBQUssUUFBUTs7O2tEQUdoQixNQUNMO1lBQUksS0FBSyxNQUFNLEtBQUssS0FBSyxPQUFPLEtBQUssVUFDaEMsS0FBSyxRQUFlLEtBQUs7WUFFMUIsS0FBSyxNQUFNLEtBQUssS0FBSyxPQUFPLEtBQUssVUFDaEMsS0FBSyxRQUFlLEtBQUs7ZUFFdkI7Ozs7O0FBZ0JYLElBSUU7dUJBQVksTUFBaUI7OzthQUN0QixRQUFRO2FBQ1IsUUFBUTs7OzJEQUdILFVBQ1Y7WUFBSSxPQUFPLEtBQUs7ZUFFVCxTQUFTLE1BQU07cUJBQ1g7bUJBQ0YsS0FBSyxTQUFTOzs7OytDQUt2QjtlQUFPLEtBQUs7OzsrQ0FJWjtlQUFPLEtBQUs7OztxREFJWjtZQUFJLE1BQVc7YUFDVjttQkFBaUIsSUFBSSxLQUFLOztlQUN4Qjs7O3FEQUdBLE1BQ1A7WUFBSSxTQUFTLEtBQUssT0FBTyxPQUFPO2VBQ3pCLEtBQUs7Ozs7O0FBSWhCLEFBQU8sSUFBTSxjQUFjLElBQUksVUFBVSxNQUFNOztJQ3JKbEMsaUNBQ1g7O1FBQ0ksYUFBYSxPQUFPLFlBQVk7UUFDaEMsQ0FBQyxZQUFZO2VBQVM7O1FBRXRCLFdBQVcsSUFBSTs7O1dBR1osT0FBTyxVQUFVLFNBQVMsS0FBSyxjQUFjO0NBUm5COztBQ0VuQyxJQUFNLG1CQUFtQixPQUFPLGdCQUFnQjtBQUVoRCxJQUFJO0FBRUosSUFBSSxrQkFBa0I7UUFDaEI7T0FDQztRQUNEOztBQUdOLFVBQWU7QUFFZixBQUFPLElBQU0sY0FBc0IscUJBQXFCLE9BQU8sT0FBTyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
