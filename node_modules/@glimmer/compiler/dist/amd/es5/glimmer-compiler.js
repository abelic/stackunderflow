define('@glimmer/compiler', ['exports', '@glimmer/syntax', '@glimmer/util', '@glimmer/wire-format'], function (exports, _glimmer_syntax, _glimmer_util, _glimmer_wireFormat) { 'use strict';

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolTable = function () {
    function SymbolTable() {
        _classCallCheck$1(this, SymbolTable);
    }

    SymbolTable.top = function top() {
        return new ProgramSymbolTable();
    };

    SymbolTable.prototype.child = function child(locals) {
        var _this = this;

        var symbols = locals.map(function (name) {
            return _this.allocate(name);
        });
        return new BlockSymbolTable(this, locals, symbols);
    };

    return SymbolTable;
}();
var ProgramSymbolTable = function (_SymbolTable) {
    _inherits(ProgramSymbolTable, _SymbolTable);

    function ProgramSymbolTable() {
        _classCallCheck$1(this, ProgramSymbolTable);

        var _this2 = _possibleConstructorReturn(this, _SymbolTable.apply(this, arguments));

        _this2.symbols = [];
        _this2.size = 1;
        _this2.named = _glimmer_util.dict();
        _this2.blocks = _glimmer_util.dict();
        return _this2;
    }

    ProgramSymbolTable.prototype.has = function has(_name) {
        return false;
    };

    ProgramSymbolTable.prototype.get = function get(_name) {
        throw _glimmer_util.unreachable();
    };

    ProgramSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        return {};
    };

    ProgramSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        return [];
    };

    ProgramSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        var named = this.named[name];
        if (!named) {
            named = this.named[name] = this.allocate('@' + name);
        }
        return named;
    };

    ProgramSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        var block = this.blocks[name];
        if (!block) {
            block = this.blocks[name] = this.allocate('&' + name);
        }
        return block;
    };

    ProgramSymbolTable.prototype.allocate = function allocate(identifier) {
        this.symbols.push(identifier);
        return this.size++;
    };

    return ProgramSymbolTable;
}(SymbolTable);
var BlockSymbolTable = function (_SymbolTable2) {
    _inherits(BlockSymbolTable, _SymbolTable2);

    function BlockSymbolTable(parent, symbols, slots) {
        _classCallCheck$1(this, BlockSymbolTable);

        var _this3 = _possibleConstructorReturn(this, _SymbolTable2.call(this));

        _this3.parent = parent;
        _this3.symbols = symbols;
        _this3.slots = slots;
        return _this3;
    }

    BlockSymbolTable.prototype.has = function has(name) {
        return this.symbols.indexOf(name) !== -1 || this.parent.has(name);
    };

    BlockSymbolTable.prototype.get = function get(name) {
        var slot = this.symbols.indexOf(name);
        return slot === -1 ? this.parent.get(name) : this.slots[slot];
    };

    BlockSymbolTable.prototype.getLocalsMap = function getLocalsMap() {
        var _this4 = this;

        var dict$$1 = this.parent.getLocalsMap();
        this.symbols.forEach(function (symbol) {
            return dict$$1[symbol] = _this4.get(symbol);
        });
        return dict$$1;
    };

    BlockSymbolTable.prototype.getEvalInfo = function getEvalInfo() {
        var locals = this.getLocalsMap();
        return Object.keys(locals).map(function (symbol) {
            return locals[symbol];
        });
    };

    BlockSymbolTable.prototype.allocateNamed = function allocateNamed(name) {
        return this.parent.allocateNamed(name);
    };

    BlockSymbolTable.prototype.allocateBlock = function allocateBlock(name) {
        return this.parent.allocateBlock(name);
    };

    BlockSymbolTable.prototype.allocate = function allocate(identifier) {
        return this.parent.allocate(identifier);
    };

    return BlockSymbolTable;
}(SymbolTable);
/**
 * Takes in an AST and outputs a list of actions to be consumed
 * by a compiler. For example, the template
 *
 *     foo{{bar}}<div>baz</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 3]],
 *      ['mustache', [mustacheNode, 1, 3]],
 *      ['openElement', [elementNode, 2, 3, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['closeElement', [elementNode, 2, 3],
 *      ['endProgram', [programNode]]]
 *
 * This visitor walks the AST depth first and backwards. As
 * a result the bottom-most child template will appear at the
 * top of the actions list whereas the root template will appear
 * at the bottom of the list. For example,
 *
 *     <div>{{#if}}foo{{else}}bar<b></b>{{/if}}</div>
 *
 * produces the actions
 *
 *     [['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 2, 0]],
 *      ['openElement', [elementNode, 1, 2, 0]],
 *      ['closeElement', [elementNode, 1, 2]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 0]],
 *      ['text', [textNode, 0, 1]],
 *      ['endProgram', [programNode]],
 *      ['startProgram', [programNode, 2]],
 *      ['openElement', [elementNode, 0, 1, 1]],
 *      ['block', [blockNode, 0, 1]],
 *      ['closeElement', [elementNode, 0, 1]],
 *      ['endProgram', [programNode]]]
 *
 * The state of the traversal is maintained by a stack of frames.
 * Whenever a node with children is entered (either a ProgramNode
 * or an ElementNode) a frame is pushed onto the stack. The frame
 * contains information about the state of the traversal of that
 * node. For example,
 *
 *   - index of the current child node being visited
 *   - the number of mustaches contained within its child nodes
 *   - the list of actions generated by its child nodes
 */

var Frame = function Frame() {
    _classCallCheck$1(this, Frame);

    this.parentNode = null;
    this.children = null;
    this.childIndex = null;
    this.childCount = null;
    this.childTemplateCount = 0;
    this.mustacheCount = 0;
    this.actions = [];
    this.blankChildTextNodes = null;
    this.symbols = null;
};

var TemplateVisitor = function () {
    function TemplateVisitor() {
        _classCallCheck$1(this, TemplateVisitor);

        this.frameStack = [];
        this.actions = [];
        this.programDepth = -1;
    }

    TemplateVisitor.prototype.visit = function visit(node) {
        this[node.type](node);
    };
    // Traversal methods


    TemplateVisitor.prototype.Program = function Program(program) {
        var _actions;

        this.programDepth++;
        var parentFrame = this.getCurrentFrame();
        var programFrame = this.pushFrame();
        if (!parentFrame) {
            program['symbols'] = SymbolTable.top();
        } else {
            program['symbols'] = parentFrame.symbols.child(program.blockParams);
        }
        var startType = void 0,
            endType = void 0;
        if (this.programDepth === 0) {
            startType = 'startProgram';
            endType = 'endProgram';
        } else {
            startType = 'startBlock';
            endType = 'endBlock';
        }
        programFrame.parentNode = program;
        programFrame.children = program.body;
        programFrame.childCount = program.body.length;
        programFrame.blankChildTextNodes = [];
        programFrame.actions.push([endType, [program, this.programDepth]]);
        programFrame.symbols = program['symbols'];
        for (var i = program.body.length - 1; i >= 0; i--) {
            programFrame.childIndex = i;
            this.visit(program.body[i]);
        }
        programFrame.actions.push([startType, [program, programFrame.childTemplateCount, programFrame.blankChildTextNodes.reverse()]]);
        this.popFrame();
        this.programDepth--;
        // Push the completed template into the global actions list
        if (parentFrame) {
            parentFrame.childTemplateCount++;
        }
        (_actions = this.actions).push.apply(_actions, programFrame.actions.reverse());
    };

    TemplateVisitor.prototype.ElementNode = function ElementNode(element) {
        var _parentFrame$actions;

        var parentFrame = this.currentFrame;
        var elementFrame = this.pushFrame();
        elementFrame.parentNode = element;
        elementFrame.children = element.children;
        elementFrame.childCount = element.children.length;
        elementFrame.mustacheCount += element.modifiers.length;
        elementFrame.blankChildTextNodes = [];
        elementFrame.symbols = element['symbols'] = parentFrame.symbols.child(element.blockParams);
        var actionArgs = [element, parentFrame.childIndex, parentFrame.childCount];
        elementFrame.actions.push(['closeElement', actionArgs]);
        for (var i = element.attributes.length - 1; i >= 0; i--) {
            this.visit(element.attributes[i]);
        }
        for (var _i = element.children.length - 1; _i >= 0; _i--) {
            elementFrame.childIndex = _i;
            this.visit(element.children[_i]);
        }
        var open = ['openElement', [].concat(actionArgs, [elementFrame.mustacheCount, elementFrame.blankChildTextNodes.reverse()])];
        elementFrame.actions.push(open);
        this.popFrame();
        // Propagate the element's frame state to the parent frame
        if (elementFrame.mustacheCount > 0) {
            parentFrame.mustacheCount++;
        }
        parentFrame.childTemplateCount += elementFrame.childTemplateCount;
        (_parentFrame$actions = parentFrame.actions).push.apply(_parentFrame$actions, elementFrame.actions);
    };

    TemplateVisitor.prototype.AttrNode = function AttrNode(attr) {
        if (attr.value.type !== 'TextNode') {
            this.currentFrame.mustacheCount++;
        }
    };

    TemplateVisitor.prototype.TextNode = function TextNode(text) {
        var frame = this.currentFrame;
        if (text.chars === '') {
            frame.blankChildTextNodes.push(domIndexOf(frame.children, text));
        }
        frame.actions.push(['text', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.BlockStatement = function BlockStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['block', [node, frame.childIndex, frame.childCount]]);
        if (node.inverse) {
            this.visit(node.inverse);
        }
        if (node.program) {
            this.visit(node.program);
        }
    };

    TemplateVisitor.prototype.PartialStatement = function PartialStatement(node) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [node, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.CommentStatement = function CommentStatement(text) {
        var frame = this.currentFrame;
        frame.actions.push(['comment', [text, frame.childIndex, frame.childCount]]);
    };

    TemplateVisitor.prototype.MustacheCommentStatement = function MustacheCommentStatement() {
        // Intentional empty: Handlebars comments should not affect output.
    };

    TemplateVisitor.prototype.MustacheStatement = function MustacheStatement(mustache) {
        var frame = this.currentFrame;
        frame.mustacheCount++;
        frame.actions.push(['mustache', [mustache, frame.childIndex, frame.childCount]]);
    };

    // Frame helpers


    TemplateVisitor.prototype.getCurrentFrame = function getCurrentFrame() {
        return this.frameStack[this.frameStack.length - 1];
    };

    TemplateVisitor.prototype.pushFrame = function pushFrame() {
        var frame = new Frame();
        this.frameStack.push(frame);
        return frame;
    };

    TemplateVisitor.prototype.popFrame = function popFrame() {
        return this.frameStack.pop();
    };

    _createClass$1(TemplateVisitor, [{
        key: 'currentFrame',
        get: function get() {
            return this.getCurrentFrame();
        }
    }]);

    return TemplateVisitor;
}();
function domIndexOf(nodes, domNode) {
    var index = -1;
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.type !== 'TextNode' && node.type !== 'ElementNode') {
            continue;
        } else {
            index++;
        }
        if (node === domNode) {
            return index;
        }
    }
    return -1;
}

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defaults$1(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$1(subClass, superClass); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Block = function () {
    function Block() {
        _classCallCheck$2(this, Block);

        this.statements = [];
    }

    Block.prototype.push = function push(statement) {
        this.statements.push(statement);
    };

    return Block;
}();
var InlineBlock = function (_Block) {
    _inherits$1(InlineBlock, _Block);

    function InlineBlock(table) {
        _classCallCheck$2(this, InlineBlock);

        var _this = _possibleConstructorReturn$1(this, _Block.call(this));

        _this.table = table;
        return _this;
    }

    InlineBlock.prototype.toJSON = function toJSON() {
        return {
            statements: this.statements,
            parameters: this.table.slots
        };
    };

    return InlineBlock;
}(Block);
var TemplateBlock = function (_Block2) {
    _inherits$1(TemplateBlock, _Block2);

    function TemplateBlock(symbolTable) {
        _classCallCheck$2(this, TemplateBlock);

        var _this2 = _possibleConstructorReturn$1(this, _Block2.call(this));

        _this2.symbolTable = symbolTable;
        _this2.type = "template";
        _this2.yields = new _glimmer_util.DictSet();
        _this2.named = new _glimmer_util.DictSet();
        _this2.blocks = [];
        _this2.hasEval = false;
        return _this2;
    }

    TemplateBlock.prototype.push = function push(statement) {
        this.statements.push(statement);
    };

    TemplateBlock.prototype.toJSON = function toJSON() {
        return {
            symbols: this.symbolTable.symbols,
            statements: this.statements,
            hasEval: this.hasEval
        };
    };

    return TemplateBlock;
}(Block);
var ComponentBlock = function (_Block3) {
    _inherits$1(ComponentBlock, _Block3);

    function ComponentBlock(table) {
        _classCallCheck$2(this, ComponentBlock);

        var _this3 = _possibleConstructorReturn$1(this, _Block3.call(this));

        _this3.table = table;
        _this3.attributes = [];
        _this3.arguments = [];
        _this3.inParams = true;
        _this3.positionals = [];
        return _this3;
    }

    ComponentBlock.prototype.push = function push(statement) {
        if (this.inParams) {
            if (_glimmer_wireFormat.Statements.isModifier(statement)) {
                throw new Error('Compile Error: Element modifiers are not allowed in components');
            } else if (_glimmer_wireFormat.Statements.isFlushElement(statement)) {
                this.inParams = false;
            } else if (_glimmer_wireFormat.Statements.isArgument(statement)) {
                this.arguments.push(statement);
            } else if (_glimmer_wireFormat.Statements.isAttribute(statement)) {
                this.attributes.push(statement);
            } else {
                throw new Error('Compile Error: only parameters allowed before flush-element');
            }
        } else {
            this.statements.push(statement);
        }
    };

    ComponentBlock.prototype.toJSON = function toJSON() {
        var args = this.arguments;
        var keys = args.map(function (arg) {
            return arg[1];
        });
        var values = args.map(function (arg) {
            return arg[2];
        });
        return [this.attributes, [keys, values], {
            statements: this.statements,
            parameters: this.table.slots
        }];
    };

    return ComponentBlock;
}(Block);
var Template = function () {
    function Template(symbols, meta) {
        _classCallCheck$2(this, Template);

        this.meta = meta;
        this.block = new TemplateBlock(symbols);
    }

    Template.prototype.toJSON = function toJSON() {
        return {
            block: this.block.toJSON(),
            meta: this.meta
        };
    };

    return Template;
}();

var JavaScriptCompiler = function () {
    function JavaScriptCompiler(opcodes, symbols, meta) {
        _classCallCheck$2(this, JavaScriptCompiler);

        this.blocks = new _glimmer_util.Stack();
        this.values = [];
        this.opcodes = opcodes;
        this.template = new Template(symbols, meta);
    }

    JavaScriptCompiler.process = function process(opcodes, symbols, meta) {
        var compiler = new JavaScriptCompiler(opcodes, symbols, meta);
        return compiler.process();
    };

    JavaScriptCompiler.prototype.process = function process() {
        var _this4 = this;

        this.opcodes.forEach(function (_ref) {
            var opcode = _ref[0],
                args = _ref.slice(1);

            if (!_this4[opcode]) {
                throw new Error("unimplemented " + opcode + " on JavaScriptCompiler");
            }
            _this4[opcode].apply(_this4, args);
        });
        return this.template;
    };
    /// Nesting


    JavaScriptCompiler.prototype.startBlock = function startBlock(_ref2) {
        var program = _ref2[0];

        var block = new InlineBlock(program['symbols']);
        this.blocks.push(block);
    };

    JavaScriptCompiler.prototype.endBlock = function endBlock() {
        var template = this.template,
            blocks = this.blocks;

        var block = blocks.pop();
        template.block.blocks.push(block.toJSON());
    };

    JavaScriptCompiler.prototype.startProgram = function startProgram() {
        this.blocks.push(this.template.block);
    };

    JavaScriptCompiler.prototype.endProgram = function endProgram() {};
    /// Statements


    JavaScriptCompiler.prototype.text = function text(content) {
        this.push([_glimmer_wireFormat.Ops.Text, content]);
    };

    JavaScriptCompiler.prototype.append = function append(trusted) {
        this.push([_glimmer_wireFormat.Ops.Append, this.popValue(), trusted]);
    };

    JavaScriptCompiler.prototype.comment = function comment(value) {
        this.push([_glimmer_wireFormat.Ops.Comment, value]);
    };

    JavaScriptCompiler.prototype.modifier = function modifier(name) {
        var params = this.popValue();
        var hash = this.popValue();
        this.push([_glimmer_wireFormat.Ops.Modifier, name, params, hash]);
    };

    JavaScriptCompiler.prototype.block = function block(name, template, inverse) {
        var params = this.popValue();
        var hash = this.popValue();
        var blocks = this.template.block.blocks;
        _glimmer_util.assert(typeof template !== 'number' || blocks[template] !== null, 'missing block in the compiler');
        _glimmer_util.assert(typeof inverse !== 'number' || blocks[inverse] !== null, 'missing block in the compiler');
        this.push([_glimmer_wireFormat.Ops.Block, name, params, hash, blocks[template], blocks[inverse]]);
    };

    JavaScriptCompiler.prototype.openSplattedElement = function openSplattedElement(element) {
        var tag = element.tag;
        if (isComponent(tag)) {
            throw new Error("Compile Error: ...attributes can only be used in an element");
        } else if (element.blockParams.length > 0) {
            throw new Error("Compile Error: <" + element.tag + "> is not a component and doesn't support block parameters");
        } else {
            this.push([_glimmer_wireFormat.Ops.OpenSplattedElement, tag]);
        }
    };

    JavaScriptCompiler.prototype.openElement = function openElement(element) {
        var tag = element.tag;
        if (isComponent(tag)) {
            this.startComponent(element);
        } else if (element.blockParams.length > 0) {
            throw new Error("Compile Error: <" + element.tag + "> is not a component and doesn't support block parameters");
        } else {
            this.push([_glimmer_wireFormat.Ops.OpenElement, tag]);
        }
    };

    JavaScriptCompiler.prototype.flushElement = function flushElement() {
        this.push([_glimmer_wireFormat.Ops.FlushElement]);
    };

    JavaScriptCompiler.prototype.closeElement = function closeElement(element) {
        var tag = element.tag;
        if (isComponent(tag)) {
            var _endComponent = this.endComponent(),
                attrs = _endComponent[0],
                args = _endComponent[1],
                block = _endComponent[2];

            this.push([_glimmer_wireFormat.Ops.Component, tag, attrs, args, block]);
        } else {
            this.push([_glimmer_wireFormat.Ops.CloseElement]);
        }
    };

    JavaScriptCompiler.prototype.staticAttr = function staticAttr(name, namespace) {
        var value = this.popValue();
        this.push([_glimmer_wireFormat.Ops.StaticAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.dynamicAttr = function dynamicAttr(name, namespace) {
        var value = this.popValue();
        this.push([_glimmer_wireFormat.Ops.DynamicAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.trustingAttr = function trustingAttr(name, namespace) {
        var value = this.popValue();
        this.push([_glimmer_wireFormat.Ops.TrustingAttr, name, value, namespace]);
    };

    JavaScriptCompiler.prototype.staticArg = function staticArg(name) {
        var value = this.popValue();
        this.push([_glimmer_wireFormat.Ops.StaticArg, name, value]);
    };

    JavaScriptCompiler.prototype.dynamicArg = function dynamicArg(name) {
        var value = this.popValue();
        this.push([_glimmer_wireFormat.Ops.DynamicArg, name, value]);
    };

    JavaScriptCompiler.prototype.yield = function _yield(to) {
        var params = this.popValue();
        this.push([_glimmer_wireFormat.Ops.Yield, to, params]);
    };

    JavaScriptCompiler.prototype.attrSplat = function attrSplat(to) {
        this.push([_glimmer_wireFormat.Ops.AttrSplat, to]);
    };

    JavaScriptCompiler.prototype.debugger = function _debugger(evalInfo) {
        this.push([_glimmer_wireFormat.Ops.Debugger, evalInfo]);
        this.template.block.hasEval = true;
    };

    JavaScriptCompiler.prototype.hasBlock = function hasBlock(name) {
        this.pushValue([_glimmer_wireFormat.Ops.HasBlock, name]);
    };

    JavaScriptCompiler.prototype.hasBlockParams = function hasBlockParams(name) {
        this.pushValue([_glimmer_wireFormat.Ops.HasBlockParams, name]);
    };

    JavaScriptCompiler.prototype.partial = function partial(evalInfo) {
        var params = this.popValue();
        this.push([_glimmer_wireFormat.Ops.Partial, params[0], evalInfo]);
        this.template.block.hasEval = true;
    };
    /// Expressions


    JavaScriptCompiler.prototype.literal = function literal(value) {
        if (value === undefined) {
            this.pushValue([_glimmer_wireFormat.Ops.Undefined]);
        } else {
            this.pushValue(value);
        }
    };

    JavaScriptCompiler.prototype.unknown = function unknown(name) {
        this.pushValue([_glimmer_wireFormat.Ops.Unknown, name]);
    };

    JavaScriptCompiler.prototype.get = function get(head, path) {
        this.pushValue([_glimmer_wireFormat.Ops.Get, head, path]);
    };

    JavaScriptCompiler.prototype.maybeLocal = function maybeLocal(path) {
        this.pushValue([_glimmer_wireFormat.Ops.MaybeLocal, path]);
    };

    JavaScriptCompiler.prototype.concat = function concat() {
        this.pushValue([_glimmer_wireFormat.Ops.Concat, this.popValue()]);
    };

    JavaScriptCompiler.prototype.helper = function helper(name) {
        var params = this.popValue();
        var hash = this.popValue();
        this.pushValue([_glimmer_wireFormat.Ops.Helper, name, params, hash]);
    };
    /// Stack Management Opcodes


    JavaScriptCompiler.prototype.startComponent = function startComponent(element) {
        var component = new ComponentBlock(element['symbols']);
        this.blocks.push(component);
    };

    JavaScriptCompiler.prototype.endComponent = function endComponent() {
        var component = this.blocks.pop();
        _glimmer_util.assert(component instanceof ComponentBlock, "Compiler bug: endComponent() should end a component");
        return component.toJSON();
    };

    JavaScriptCompiler.prototype.prepareArray = function prepareArray(size) {
        var values = [];
        for (var i = 0; i < size; i++) {
            values.push(this.popValue());
        }
        this.pushValue(values);
    };

    JavaScriptCompiler.prototype.prepareObject = function prepareObject(size) {
        _glimmer_util.assert(this.values.length >= size, "Expected " + size + " values on the stack, found " + this.values.length);
        var keys = new Array(size);
        var values = new Array(size);
        for (var i = 0; i < size; i++) {
            keys[i] = this.popValue();
            values[i] = this.popValue();
        }
        this.pushValue([keys, values]);
    };
    /// Utilities


    JavaScriptCompiler.prototype.push = function push(args) {
        while (args[args.length - 1] === null) {
            args.pop();
        }
        this.currentBlock.push(args);
    };

    JavaScriptCompiler.prototype.pushValue = function pushValue(val) {
        this.values.push(val);
    };

    JavaScriptCompiler.prototype.popValue = function popValue() {
        _glimmer_util.assert(this.values.length, "No expression found on stack");
        return this.values.pop();
    };

    _createClass$2(JavaScriptCompiler, [{
        key: "currentBlock",
        get: function get() {
            return this.blocks.current;
        }
    }]);

    return JavaScriptCompiler;
}();

function isComponent(tag) {
    var open = tag.charAt(0);
    return open === open.toUpperCase();
}

// There is a small whitelist of namespaced attributes specially
// enumerated in
// https://www.w3.org/TR/html/syntax.html#attributes-0
//
// > When a foreign element has one of the namespaced attributes given by
// > the local name and namespace of the first and second cells of a row
// > from the following table, it must be written using the name given by
// > the third cell from the same row.
//
// In all other cases, colons are interpreted as a regular character
// with no special meaning:
//
// > No other namespaced attribute can be expressed in the HTML syntax.
var XLINK = 'http://www.w3.org/1999/xlink';
var XML = 'http://www.w3.org/XML/1998/namespace';
var XMLNS = 'http://www.w3.org/2000/xmlns/';
var WHITELIST = {
    'xlink:actuate': XLINK,
    'xlink:arcrole': XLINK,
    'xlink:href': XLINK,
    'xlink:role': XLINK,
    'xlink:show': XLINK,
    'xlink:title': XLINK,
    'xlink:type': XLINK,
    'xml:base': XML,
    'xml:lang': XML,
    'xml:space': XML,
    'xmlns': XMLNS,
    'xmlns:xlink': XMLNS
};
function getAttrNamespace(attrName) {
    return WHITELIST[attrName] || null;
}

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isTrustedValue(value) {
    return value.escaped !== undefined && !value.escaped;
}

var TemplateCompiler = function () {
    function TemplateCompiler(options) {
        _classCallCheck(this, TemplateCompiler);

        this.templateId = 0;
        this.templateIds = [];
        this.symbolStack = new _glimmer_util.Stack();
        this.opcodes = [];
        this.includeMeta = false;
        this.options = options || {};
    }

    TemplateCompiler.compile = function compile(options, ast) {
        var templateVisitor = new TemplateVisitor();
        templateVisitor.visit(ast);
        var compiler = new TemplateCompiler(options);
        var opcodes = compiler.process(templateVisitor.actions);
        return JavaScriptCompiler.process(opcodes, ast['symbols'], options.meta);
    };

    TemplateCompiler.prototype.process = function process(actions) {
        var _this = this;

        actions.forEach(function (_ref) {
            var name = _ref[0],
                args = _ref.slice(1);

            if (!_this[name]) {
                throw new Error("Unimplemented " + name + " on TemplateCompiler");
            }
            _this[name].apply(_this, args);
        });
        return this.opcodes;
    };

    TemplateCompiler.prototype.startProgram = function startProgram(program) {
        this.symbolStack.push(program[0]['symbols']);
        this.opcode('startProgram', program, program);
    };

    TemplateCompiler.prototype.endProgram = function endProgram() {
        this.symbolStack.pop();
        this.opcode('endProgram', null);
    };

    TemplateCompiler.prototype.startBlock = function startBlock(program) {
        this.symbolStack.push(program[0]['symbols']);
        this.templateId++;
        this.opcode('startBlock', program, program);
    };

    TemplateCompiler.prototype.endBlock = function endBlock() {
        this.symbolStack.pop();
        this.templateIds.push(this.templateId - 1);
        this.opcode('endBlock', null);
    };

    TemplateCompiler.prototype.text = function text(_ref2) {
        var action = _ref2[0];

        this.opcode('text', action, action.chars);
    };

    TemplateCompiler.prototype.comment = function comment(_ref3) {
        var action = _ref3[0];

        this.opcode('comment', action, action.value);
    };

    TemplateCompiler.prototype.openElement = function openElement(_ref4) {
        var action = _ref4[0];

        var attributes = action.attributes;
        var hasSplat = void 0;
        for (var i = 0; i < attributes.length; i++) {
            var attr = attributes[i];
            if (attr.name === '...attributes') {
                hasSplat = attr;
                break;
            }
        }
        if (hasSplat) {
            this.opcode('openSplattedElement', action, action);
        } else {
            this.opcode('openElement', action, action);
        }
        for (var _i = 0; _i < action.attributes.length; _i++) {
            this.attribute([action.attributes[_i]]);
        }
        for (var _i2 = 0; _i2 < action.modifiers.length; _i2++) {
            this.modifier([action.modifiers[_i2]]);
        }
        this.opcode('flushElement', null);
        this.symbolStack.push(action['symbols']);
    };

    TemplateCompiler.prototype.closeElement = function closeElement(_ref5) {
        var action = _ref5[0];

        this.symbolStack.pop();
        this.opcode('closeElement', null, action);
    };

    TemplateCompiler.prototype.attribute = function attribute(_ref6) {
        var action = _ref6[0];
        var name = action.name,
            value = action.value;

        var namespace = getAttrNamespace(name);
        var isStatic = this.prepareAttributeValue(value);
        if (name.charAt(0) === '@') {
            // Arguments
            if (isStatic) {
                this.opcode('staticArg', action, name);
            } else if (action.value.type === 'MustacheStatement') {
                this.opcode('dynamicArg', action, name);
            } else {
                this.opcode('dynamicArg', action, name);
            }
        } else {
            var isTrusting = isTrustedValue(value);
            if (isStatic && name === '...attributes') {
                this.opcode('attrSplat', action, this.symbols.allocateBlock('attrs'));
            } else if (isStatic) {
                this.opcode('staticAttr', action, name, namespace);
            } else if (isTrusting) {
                this.opcode('trustingAttr', action, name, namespace);
            } else if (action.value.type === 'MustacheStatement') {
                this.opcode('dynamicAttr', action, name);
            } else {
                this.opcode('dynamicAttr', action, name, namespace);
            }
        }
    };

    TemplateCompiler.prototype.modifier = function modifier(_ref7) {
        var action = _ref7[0];

        assertIsSimplePath(action.path, action.loc, 'modifier');
        var parts = action.path.parts;

        this.prepareHelper(action);
        this.opcode('modifier', action, parts[0]);
    };

    TemplateCompiler.prototype.mustache = function mustache(_ref8) {
        var action = _ref8[0];
        var path = action.path;

        if (_glimmer_syntax.isLiteral(path)) {
            this.mustacheExpression(action);
            this.opcode('append', action, !action.escaped);
        } else if (isYield(path)) {
            var to = assertValidYield(action);
            this.yield(to, action);
        } else if (isPartial(path)) {
            var params = assertValidPartial(action);
            this.partial(params, action);
        } else if (isDebugger(path)) {
            assertValidDebuggerUsage(action);
            this.debugger('debugger', action);
        } else {
            this.mustacheExpression(action);
            this.opcode('append', action, !action.escaped);
        }
    };

    TemplateCompiler.prototype.block = function block(_ref9) {
        var action /*, index, count*/ = _ref9[0];

        this.prepareHelper(action);
        var templateId = this.templateIds.pop();
        var inverseId = action.inverse === null ? null : this.templateIds.pop();
        this.opcode('block', action, action.path.parts[0], templateId, inverseId);
    };
    /// Internal actions, not found in the original processed actions


    TemplateCompiler.prototype.arg = function arg(_ref10) {
        var path = _ref10[0];

        var _path$parts = path.parts,
            head = _path$parts[0],
            rest = _path$parts.slice(1);

        var symbol = this.symbols.allocateNamed(head);
        this.opcode('get', path, symbol, rest);
    };

    TemplateCompiler.prototype.mustacheExpression = function mustacheExpression(expr) {
        var path = expr.path;

        if (_glimmer_syntax.isLiteral(path)) {
            this.opcode('literal', expr, path.value);
        } else if (isBuiltInHelper(path)) {
            this.builtInHelper(expr);
        } else if (isArg(path)) {
            this.arg([path]);
        } else if (isHelperInvocation(expr)) {
            this.prepareHelper(expr);
            this.opcode('helper', expr, path.parts[0]);
        } else if (path.this) {
            this.opcode('get', expr, 0, path.parts);
        } else if (isLocal(path, this.symbols)) {
            var _path$parts2 = path.parts,
                head = _path$parts2[0],
                parts = _path$parts2.slice(1);

            this.opcode('get', expr, this.symbols.get(head), parts);
        } else if (isSimplePath(path)) {
            this.opcode('unknown', expr, path.parts[0]);
        } else {
            this.opcode('maybeLocal', expr, path.parts);
        }
    };
    /// Internal Syntax


    TemplateCompiler.prototype.yield = function _yield(to, action) {
        this.prepareParams(action.params);
        this.opcode('yield', action, this.symbols.allocateBlock(to));
    };

    TemplateCompiler.prototype.debugger = function _debugger(_name, action) {
        this.opcode('debugger', action, this.symbols.getEvalInfo());
    };

    TemplateCompiler.prototype.hasBlock = function hasBlock(name, action) {
        this.opcode('hasBlock', action, this.symbols.allocateBlock(name));
    };

    TemplateCompiler.prototype.hasBlockParams = function hasBlockParams(name, action) {
        this.opcode('hasBlockParams', action, this.symbols.allocateBlock(name));
    };

    TemplateCompiler.prototype.partial = function partial(_params, action) {
        this.prepareParams(action.params);
        this.opcode('partial', action, this.symbols.getEvalInfo());
    };

    TemplateCompiler.prototype.builtInHelper = function builtInHelper(expr) {
        var path = expr.path;

        if (isHasBlock(path)) {
            var name = assertValidHasBlockUsage(expr.path.original, expr);
            this.hasBlock(name, expr);
        } else if (isHasBlockParams(path)) {
            var _name2 = assertValidHasBlockUsage(expr.path.original, expr);
            this.hasBlockParams(_name2, expr);
        }
    };
    /// Expressions, invoked recursively from prepareParams and prepareHash


    TemplateCompiler.prototype.SubExpression = function SubExpression(expr) {
        if (isBuiltInHelper(expr.path)) {
            this.builtInHelper(expr);
        } else {
            this.prepareHelper(expr);
            this.opcode('helper', expr, expr.path.parts[0]);
        }
    };

    TemplateCompiler.prototype.PathExpression = function PathExpression(expr) {
        if (expr.data) {
            this.arg([expr]);
        } else {
            var symbols = this.symbols;
            var _expr$parts = expr.parts,
                head = _expr$parts[0];

            if (expr.this) {
                this.opcode('get', expr, 0, expr.parts);
            } else if (symbols.has(head)) {
                this.opcode('get', expr, symbols.get(head), expr.parts.slice(1));
            } else {
                this.opcode('get', expr, 0, expr.parts);
            }
        }
    };

    TemplateCompiler.prototype.StringLiteral = function StringLiteral(action) {
        this.opcode('literal', null, action.value);
    };

    TemplateCompiler.prototype.BooleanLiteral = function BooleanLiteral(action) {
        this.opcode('literal', null, action.value);
    };

    TemplateCompiler.prototype.NumberLiteral = function NumberLiteral(action) {
        this.opcode('literal', null, action.value);
    };

    TemplateCompiler.prototype.NullLiteral = function NullLiteral(action) {
        this.opcode('literal', null, action.value);
    };

    TemplateCompiler.prototype.UndefinedLiteral = function UndefinedLiteral(action) {
        this.opcode('literal', null, action.value);
    };
    /// Utilities


    TemplateCompiler.prototype.opcode = function opcode(name, action) {
        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
        }

        var opcode = [name].concat(args);
        if (this.includeMeta && action) {
            opcode.push(this.meta(action));
        }
        this.opcodes.push(opcode);
    };

    TemplateCompiler.prototype.prepareHelper = function prepareHelper(expr) {
        assertIsSimplePath(expr.path, expr.loc, 'helper');
        var params = expr.params,
            hash = expr.hash;

        this.prepareHash(hash);
        this.prepareParams(params);
    };

    TemplateCompiler.prototype.prepareParams = function prepareParams(params) {
        if (!params.length) {
            this.opcode('literal', null, null);
            return;
        }
        for (var i = params.length - 1; i >= 0; i--) {
            var param = params[i];
            _glimmer_util.assert(this[param.type], "Unimplemented " + param.type + " on TemplateCompiler");
            this[param.type](param);
        }
        this.opcode('prepareArray', null, params.length);
    };

    TemplateCompiler.prototype.prepareHash = function prepareHash(hash) {
        var pairs = hash.pairs;
        if (!pairs.length) {
            this.opcode('literal', null, null);
            return;
        }
        for (var i = pairs.length - 1; i >= 0; i--) {
            var _pairs$i = pairs[i],
                key = _pairs$i.key,
                value = _pairs$i.value;

            _glimmer_util.assert(this[value.type], "Unimplemented " + value.type + " on TemplateCompiler");
            this[value.type](value);
            this.opcode('literal', null, key);
        }
        this.opcode('prepareObject', null, pairs.length);
    };

    TemplateCompiler.prototype.prepareAttributeValue = function prepareAttributeValue(value) {
        // returns the static value if the value is static
        switch (value.type) {
            case 'TextNode':
                this.opcode('literal', value, value.chars);
                return true;
            case 'MustacheStatement':
                this.attributeMustache([value]);
                return false;
            case 'ConcatStatement':
                this.prepareConcatParts(value.parts);
                this.opcode('concat', value);
                return false;
        }
    };

    TemplateCompiler.prototype.prepareConcatParts = function prepareConcatParts(parts) {
        for (var i = parts.length - 1; i >= 0; i--) {
            var part = parts[i];
            if (part.type === 'MustacheStatement') {
                this.attributeMustache([part]);
            } else if (part.type === 'TextNode') {
                this.opcode('literal', null, part.chars);
            }
        }
        this.opcode('prepareArray', null, parts.length);
    };

    TemplateCompiler.prototype.attributeMustache = function attributeMustache(_ref11) {
        var action = _ref11[0];

        this.mustacheExpression(action);
    };

    TemplateCompiler.prototype.meta = function meta(node) {
        var loc = node.loc;
        if (!loc) {
            return [];
        }
        var source = loc.source,
            start = loc.start,
            end = loc.end;

        return ['loc', [source || null, [start.line, start.column], [end.line, end.column]]];
    };

    _createClass(TemplateCompiler, [{
        key: "symbols",
        get: function get() {
            return this.symbolStack.current;
        }
    }]);

    return TemplateCompiler;
}();

function isHelperInvocation(mustache) {
    return mustache.params && mustache.params.length > 0 || mustache.hash && mustache.hash.pairs.length > 0;
}
function isSimplePath(_ref12) {
    var parts = _ref12.parts;

    return parts.length === 1;
}
function isLocal(_ref13, symbols) {
    var parts = _ref13.parts;

    return symbols && symbols.has(parts[0]);
}
function isYield(path) {
    return path.original === 'yield';
}
function isPartial(path) {
    return path.original === 'partial';
}
function isDebugger(path) {
    return path.original === 'debugger';
}
function isHasBlock(path) {
    return path.original === 'has-block';
}
function isHasBlockParams(path) {
    return path.original === 'has-block-params';
}
function isBuiltInHelper(path) {
    return isHasBlock(path) || isHasBlockParams(path);
}
function isArg(path) {
    return !!path['data'];
}
function assertIsSimplePath(path, loc, context) {
    if (!isSimplePath(path)) {
        throw new _glimmer_syntax.SyntaxError("`" + path.original + "` is not a valid name for a " + context + " on line " + loc.start.line + ".", path.loc);
    }
}
function assertValidYield(statement) {
    var pairs = statement.hash.pairs;

    if (pairs.length === 1 && pairs[0].key !== 'to' || pairs.length > 1) {
        throw new _glimmer_syntax.SyntaxError("yield only takes a single named argument: 'to'", statement.loc);
    } else if (pairs.length === 1 && pairs[0].value.type !== 'StringLiteral') {
        throw new _glimmer_syntax.SyntaxError("you can only yield to a literal value", statement.loc);
    } else if (pairs.length === 0) {
        return 'default';
    } else {
        return pairs[0].value.value;
    }
}
function assertValidPartial(statement) {
    var params = statement.params,
        hash = statement.hash,
        escaped = statement.escaped,
        loc = statement.loc;

    if (params && params.length !== 1) {
        throw new _glimmer_syntax.SyntaxError("Partial found with no arguments. You must specify a template name. (on line " + loc.start.line + ")", statement.loc);
    } else if (hash && hash.pairs.length > 0) {
        throw new _glimmer_syntax.SyntaxError("partial does not take any named arguments (on line " + loc.start.line + ")", statement.loc);
    } else if (!escaped) {
        throw new _glimmer_syntax.SyntaxError("{{{partial ...}}} is not supported, please use {{partial ...}} instead (on line " + loc.start.line + ")", statement.loc);
    }
    return params;
}
function assertValidHasBlockUsage(type, call) {
    var params = call.params,
        hash = call.hash,
        loc = call.loc;

    if (hash && hash.pairs.length > 0) {
        throw new _glimmer_syntax.SyntaxError(type + " does not take any named arguments", call.loc);
    }
    if (params.length === 0) {
        return 'default';
    } else if (params.length === 1) {
        var param = params[0];
        if (param.type === 'StringLiteral') {
            return param.value;
        } else {
            throw new _glimmer_syntax.SyntaxError("you can only yield to a literal value (on line " + loc.start.line + ")", call.loc);
        }
    } else {
        throw new _glimmer_syntax.SyntaxError(type + " only takes a single positional argument (on line " + loc.start.line + ")", call.loc);
    }
}
function assertValidDebuggerUsage(statement) {
    var params = statement.params,
        hash = statement.hash;

    if (hash && hash.pairs.length > 0) {
        throw new _glimmer_syntax.SyntaxError("debugger does not take any named arguments", statement.loc);
    }
    if (params.length === 0) {
        return 'default';
    } else {
        throw new _glimmer_syntax.SyntaxError("debugger does not take any positional arguments", statement.loc);
    }
}

var defaultId = function () {
    if (typeof require === 'function') {
        try {
            /* tslint:disable:no-require-imports */
            var crypto = require('crypto');
            /* tslint:enable:no-require-imports */
            var idFn = function idFn(src) {
                var hash = crypto.createHash('sha1');
                hash.update(src, 'utf8');
                // trim to 6 bytes of data (2^48 - 1)
                return hash.digest('base64').substring(0, 8);
            };
            idFn("test");
            return idFn;
        } catch (e) {}
    }
    return function idFn() {
        return null;
    };
}();
var defaultOptions = {
    id: defaultId,
    meta: {}
};
function precompile(string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

    var ast = _glimmer_syntax.preprocess(string, options);

    var _TemplateCompiler$com = TemplateCompiler.compile(options, ast),
        block = _TemplateCompiler$com.block,
        meta = _TemplateCompiler$com.meta;

    var idFn = options.id || defaultId;
    var blockJSON = JSON.stringify(block.toJSON());
    var templateJSONObject = {
        id: idFn(JSON.stringify(meta) + blockJSON),
        block: blockJSON,
        meta: meta
    };
    // JSON is javascript
    return JSON.stringify(templateJSONObject);
}

exports.precompile = precompile;
exports.TemplateVisitor = TemplateVisitor;

Object.defineProperty(exports, '__esModule', { value: true });

});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1jb21waWxlci5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvY29tcGlsZXIvbGliL3RlbXBsYXRlLXZpc2l0b3IudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9jb21waWxlci9saWIvamF2YXNjcmlwdC1jb21waWxlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi91dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9jb21waWxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBU1QgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuaW1wb3J0IHsgQ29yZSB9IGZyb20gJ0BnbGltbWVyL3dpcmUtZm9ybWF0JztcbmltcG9ydCB7IERpY3QsIE9wdGlvbiwgZGljdCwgdW5yZWFjaGFibGUsIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3ltYm9sVGFibGUge1xuICBzdGF0aWMgdG9wKCk6IFByb2dyYW1TeW1ib2xUYWJsZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9ncmFtU3ltYm9sVGFibGUoKTtcbiAgfVxuXG4gIGFic3RyYWN0IGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuO1xuICBhYnN0cmFjdCBnZXQobmFtZTogc3RyaW5nKTogbnVtYmVyO1xuXG4gIGFic3RyYWN0IGdldExvY2Fsc01hcCgpOiBEaWN0PG51bWJlcj47XG4gIGFic3RyYWN0IGdldEV2YWxJbmZvKCk6IENvcmUuRXZhbEluZm87XG5cbiAgYWJzdHJhY3QgYWxsb2NhdGVOYW1lZChuYW1lOiBzdHJpbmcpOiBudW1iZXI7XG4gIGFic3RyYWN0IGFsbG9jYXRlQmxvY2sobmFtZTogc3RyaW5nKTogbnVtYmVyO1xuICBhYnN0cmFjdCBhbGxvY2F0ZShpZGVudGlmaWVyOiBzdHJpbmcpOiBudW1iZXI7XG5cbiAgY2hpbGQobG9jYWxzOiBzdHJpbmdbXSk6IEJsb2NrU3ltYm9sVGFibGUge1xuICAgIGxldCBzeW1ib2xzID0gbG9jYWxzLm1hcChuYW1lID0+IHRoaXMuYWxsb2NhdGUobmFtZSkpO1xuICAgIHJldHVybiBuZXcgQmxvY2tTeW1ib2xUYWJsZSh0aGlzLCBsb2NhbHMsIHN5bWJvbHMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmFtU3ltYm9sVGFibGUgZXh0ZW5kcyBTeW1ib2xUYWJsZSB7XG4gIHB1YmxpYyBzeW1ib2xzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIHByaXZhdGUgc2l6ZSA9IDE7XG4gIHByaXZhdGUgbmFtZWQgPSBkaWN0PG51bWJlcj4oKTtcbiAgcHJpdmF0ZSBibG9ja3MgPSBkaWN0PG51bWJlcj4oKTtcblxuICBoYXMoX25hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldChfbmFtZTogc3RyaW5nKTogbmV2ZXIge1xuICAgIHRocm93IHVucmVhY2hhYmxlKCk7XG4gIH1cblxuICBnZXRMb2NhbHNNYXAoKTogRGljdDxudW1iZXI+IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBnZXRFdmFsSW5mbygpOiBDb3JlLkV2YWxJbmZvIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhbGxvY2F0ZU5hbWVkKG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IG5hbWVkID0gdGhpcy5uYW1lZFtuYW1lXTtcblxuICAgIGlmICghbmFtZWQpIHtcbiAgICAgIG5hbWVkID0gdGhpcy5uYW1lZFtuYW1lXSA9IHRoaXMuYWxsb2NhdGUoYEAke25hbWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWVkO1xuICB9XG5cbiAgYWxsb2NhdGVCbG9jayhuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGxldCBibG9jayA9IHRoaXMuYmxvY2tzW25hbWVdO1xuXG4gICAgaWYgKCFibG9jaykge1xuICAgICAgYmxvY2sgPSB0aGlzLmJsb2Nrc1tuYW1lXSA9IHRoaXMuYWxsb2NhdGUoYCYke25hbWV9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgYWxsb2NhdGUoaWRlbnRpZmllcjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICB0aGlzLnN5bWJvbHMucHVzaChpZGVudGlmaWVyKTtcbiAgICByZXR1cm4gdGhpcy5zaXplKys7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJsb2NrU3ltYm9sVGFibGUgZXh0ZW5kcyBTeW1ib2xUYWJsZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGFyZW50OiBTeW1ib2xUYWJsZSwgcHVibGljIHN5bWJvbHM6IHN0cmluZ1tdLCBwdWJsaWMgc2xvdHM6IG51bWJlcltdKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKHRoaXMuc3ltYm9scy5pbmRleE9mKG5hbWUpICE9PSAtMSkgfHwgdGhpcy5wYXJlbnQuaGFzKG5hbWUpO1xuICB9XG5cbiAgZ2V0KG5hbWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IHNsb3QgPSB0aGlzLnN5bWJvbHMuaW5kZXhPZihuYW1lKTtcbiAgICByZXR1cm4gc2xvdCA9PT0gLTEgPyB0aGlzLnBhcmVudC5nZXQobmFtZSkgOiB0aGlzLnNsb3RzW3Nsb3RdO1xuICB9XG5cbiAgZ2V0TG9jYWxzTWFwKCk6IERpY3Q8bnVtYmVyPiB7XG4gICAgbGV0IGRpY3QgPSB0aGlzLnBhcmVudC5nZXRMb2NhbHNNYXAoKTtcbiAgICB0aGlzLnN5bWJvbHMuZm9yRWFjaChzeW1ib2wgPT4gZGljdFtzeW1ib2xdID0gdGhpcy5nZXQoc3ltYm9sKSk7XG4gICAgcmV0dXJuIGRpY3Q7XG4gIH1cblxuICBnZXRFdmFsSW5mbygpOiBDb3JlLkV2YWxJbmZvIHtcbiAgICBsZXQgbG9jYWxzID0gdGhpcy5nZXRMb2NhbHNNYXAoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobG9jYWxzKS5tYXAoc3ltYm9sID0+IGxvY2Fsc1tzeW1ib2xdKTtcbiAgfVxuXG4gIGFsbG9jYXRlTmFtZWQobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYWxsb2NhdGVOYW1lZChuYW1lKTtcbiAgfVxuXG4gIGFsbG9jYXRlQmxvY2sobmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYWxsb2NhdGVCbG9jayhuYW1lKTtcbiAgfVxuXG4gIGFsbG9jYXRlKGlkZW50aWZpZXI6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmFsbG9jYXRlKGlkZW50aWZpZXIpO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgaW4gYW4gQVNUIGFuZCBvdXRwdXRzIGEgbGlzdCBvZiBhY3Rpb25zIHRvIGJlIGNvbnN1bWVkXG4gKiBieSBhIGNvbXBpbGVyLiBGb3IgZXhhbXBsZSwgdGhlIHRlbXBsYXRlXG4gKlxuICogICAgIGZvb3t7YmFyfX08ZGl2PmJhejwvZGl2PlxuICpcbiAqIHByb2R1Y2VzIHRoZSBhY3Rpb25zXG4gKlxuICogICAgIFtbJ3N0YXJ0UHJvZ3JhbScsIFtwcm9ncmFtTm9kZSwgMF1dLFxuICogICAgICBbJ3RleHQnLCBbdGV4dE5vZGUsIDAsIDNdXSxcbiAqICAgICAgWydtdXN0YWNoZScsIFttdXN0YWNoZU5vZGUsIDEsIDNdXSxcbiAqICAgICAgWydvcGVuRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMiwgMywgMF1dLFxuICogICAgICBbJ3RleHQnLCBbdGV4dE5vZGUsIDAsIDFdXSxcbiAqICAgICAgWydjbG9zZUVsZW1lbnQnLCBbZWxlbWVudE5vZGUsIDIsIDNdLFxuICogICAgICBbJ2VuZFByb2dyYW0nLCBbcHJvZ3JhbU5vZGVdXV1cbiAqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3MgdGhlIEFTVCBkZXB0aCBmaXJzdCBhbmQgYmFja3dhcmRzLiBBc1xuICogYSByZXN1bHQgdGhlIGJvdHRvbS1tb3N0IGNoaWxkIHRlbXBsYXRlIHdpbGwgYXBwZWFyIGF0IHRoZVxuICogdG9wIG9mIHRoZSBhY3Rpb25zIGxpc3Qgd2hlcmVhcyB0aGUgcm9vdCB0ZW1wbGF0ZSB3aWxsIGFwcGVhclxuICogYXQgdGhlIGJvdHRvbSBvZiB0aGUgbGlzdC4gRm9yIGV4YW1wbGUsXG4gKlxuICogICAgIDxkaXY+e3sjaWZ9fWZvb3t7ZWxzZX19YmFyPGI+PC9iPnt7L2lmfX08L2Rpdj5cbiAqXG4gKiBwcm9kdWNlcyB0aGUgYWN0aW9uc1xuICpcbiAqICAgICBbWydzdGFydFByb2dyYW0nLCBbcHJvZ3JhbU5vZGUsIDBdXSxcbiAqICAgICAgWyd0ZXh0JywgW3RleHROb2RlLCAwLCAyLCAwXV0sXG4gKiAgICAgIFsnb3BlbkVsZW1lbnQnLCBbZWxlbWVudE5vZGUsIDEsIDIsIDBdXSxcbiAqICAgICAgWydjbG9zZUVsZW1lbnQnLCBbZWxlbWVudE5vZGUsIDEsIDJdXSxcbiAqICAgICAgWydlbmRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlXV0sXG4gKiAgICAgIFsnc3RhcnRQcm9ncmFtJywgW3Byb2dyYW1Ob2RlLCAwXV0sXG4gKiAgICAgIFsndGV4dCcsIFt0ZXh0Tm9kZSwgMCwgMV1dLFxuICogICAgICBbJ2VuZFByb2dyYW0nLCBbcHJvZ3JhbU5vZGVdXSxcbiAqICAgICAgWydzdGFydFByb2dyYW0nLCBbcHJvZ3JhbU5vZGUsIDJdXSxcbiAqICAgICAgWydvcGVuRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMCwgMSwgMV1dLFxuICogICAgICBbJ2Jsb2NrJywgW2Jsb2NrTm9kZSwgMCwgMV1dLFxuICogICAgICBbJ2Nsb3NlRWxlbWVudCcsIFtlbGVtZW50Tm9kZSwgMCwgMV1dLFxuICogICAgICBbJ2VuZFByb2dyYW0nLCBbcHJvZ3JhbU5vZGVdXV1cbiAqXG4gKiBUaGUgc3RhdGUgb2YgdGhlIHRyYXZlcnNhbCBpcyBtYWludGFpbmVkIGJ5IGEgc3RhY2sgb2YgZnJhbWVzLlxuICogV2hlbmV2ZXIgYSBub2RlIHdpdGggY2hpbGRyZW4gaXMgZW50ZXJlZCAoZWl0aGVyIGEgUHJvZ3JhbU5vZGVcbiAqIG9yIGFuIEVsZW1lbnROb2RlKSBhIGZyYW1lIGlzIHB1c2hlZCBvbnRvIHRoZSBzdGFjay4gVGhlIGZyYW1lXG4gKiBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3RhdGUgb2YgdGhlIHRyYXZlcnNhbCBvZiB0aGF0XG4gKiBub2RlLiBGb3IgZXhhbXBsZSxcbiAqXG4gKiAgIC0gaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hpbGQgbm9kZSBiZWluZyB2aXNpdGVkXG4gKiAgIC0gdGhlIG51bWJlciBvZiBtdXN0YWNoZXMgY29udGFpbmVkIHdpdGhpbiBpdHMgY2hpbGQgbm9kZXNcbiAqICAgLSB0aGUgbGlzdCBvZiBhY3Rpb25zIGdlbmVyYXRlZCBieSBpdHMgY2hpbGQgbm9kZXNcbiAqL1xuXG5jbGFzcyBGcmFtZSB7XG4gIHB1YmxpYyBwYXJlbnROb2RlOiBPcHRpb248T2JqZWN0PiA9IG51bGw7XG4gIHB1YmxpYyBjaGlsZHJlbjogT3B0aW9uPEFTVC5Ob2RlW10+ID0gbnVsbDtcbiAgcHVibGljIGNoaWxkSW5kZXg6IE9wdGlvbjxudW1iZXI+ID0gbnVsbDtcbiAgcHVibGljIGNoaWxkQ291bnQ6IE9wdGlvbjxudW1iZXI+ID0gbnVsbDtcbiAgcHVibGljIGNoaWxkVGVtcGxhdGVDb3VudCA9IDA7XG4gIHB1YmxpYyBtdXN0YWNoZUNvdW50ID0gMDtcbiAgcHVibGljIGFjdGlvbnM6IEFjdGlvbltdID0gW107XG4gIHB1YmxpYyBibGFua0NoaWxkVGV4dE5vZGVzOiBPcHRpb248bnVtYmVyW10+ID0gbnVsbDtcbiAgcHVibGljIHN5bWJvbHM6IE9wdGlvbjxTeW1ib2xUYWJsZT4gPSBudWxsO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEFjdGlvbiB7XG4gIGV4cG9ydCB0eXBlIFN0YXJ0UHJvZ3JhbSA9IFsnc3RhcnRQcm9ncmFtJywgW0FTVC5Qcm9ncmFtLCBudW1iZXIsIG51bWJlcltdXV07XG4gIGV4cG9ydCB0eXBlIEVuZFByb2dyYW0gPSBbJ2VuZFByb2dyYW0nLCBbQVNULlByb2dyYW0sIG51bWJlcl1dO1xuICBleHBvcnQgdHlwZSBTdGFydEJsb2NrID0gWydzdGFydEJsb2NrJywgW0FTVC5Qcm9ncmFtLCBudW1iZXIsIG51bWJlcltdXV07XG4gIGV4cG9ydCB0eXBlIEVuZEJsb2NrID0gWydlbmRCbG9jaycsIFtBU1QuUHJvZ3JhbSwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIEJsb2NrID0gWydibG9jaycsIFtBU1QuQmxvY2tTdGF0ZW1lbnQsIG51bWJlciwgbnVtYmVyXV07XG4gIGV4cG9ydCB0eXBlIE11c3RhY2hlID0gWydtdXN0YWNoZScsIFtBU1QuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1QuUGFydGlhbFN0YXRlbWVudCwgbnVtYmVyLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgT3BlbkVsZW1lbnQgPSBbJ29wZW5FbGVtZW50JywgW0FTVC5FbGVtZW50Tm9kZSwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyW11dXTtcbiAgZXhwb3J0IHR5cGUgQ2xvc2VFbGVtZW50ID0gWydjbG9zZUVsZW1lbnQnLCBbQVNULkVsZW1lbnROb2RlLCBudW1iZXIsIG51bWJlcl1dO1xuICBleHBvcnQgdHlwZSBUZXh0ID0gWyd0ZXh0JywgW0FTVC5UZXh0Tm9kZSwgbnVtYmVyLCBudW1iZXJdXTtcbiAgZXhwb3J0IHR5cGUgQ29tbWVudCA9IFsnY29tbWVudCcsIFtBU1QuQ29tbWVudFN0YXRlbWVudCwgbnVtYmVyLCBudW1iZXJdXTtcblxuICBleHBvcnQgdHlwZSBBY3Rpb24gPVxuICAgICAgU3RhcnRQcm9ncmFtXG4gICAgfCBFbmRQcm9ncmFtXG4gICAgfCBTdGFydEJsb2NrXG4gICAgfCBFbmRCbG9ja1xuICAgIHwgQmxvY2tcbiAgICB8IE11c3RhY2hlXG4gICAgfCBPcGVuRWxlbWVudFxuICAgIHwgQ2xvc2VFbGVtZW50XG4gICAgfCBUZXh0XG4gICAgfCBDb21tZW50XG4gICAgO1xufVxuXG5leHBvcnQgdHlwZSBBY3Rpb24gPSBBY3Rpb24uQWN0aW9uO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wbGF0ZVZpc2l0b3Ige1xuICBwcml2YXRlIGZyYW1lU3RhY2s6IEZyYW1lW10gPSBbXTtcbiAgcHVibGljIGFjdGlvbnM6IEFjdGlvbltdID0gW107XG4gIHByaXZhdGUgcHJvZ3JhbURlcHRoID0gLTE7XG5cbiAgdmlzaXQobm9kZTogQVNULkJhc2VOb2RlKSB7XG4gICAgdGhpc1tub2RlLnR5cGVdKG5vZGUpO1xuICB9XG5cbiAgLy8gVHJhdmVyc2FsIG1ldGhvZHNcblxuICBQcm9ncmFtKHByb2dyYW06IEFTVC5Qcm9ncmFtKSB7XG4gICAgdGhpcy5wcm9ncmFtRGVwdGgrKztcblxuICAgIGxldCBwYXJlbnRGcmFtZSA9IHRoaXMuZ2V0Q3VycmVudEZyYW1lKCk7XG4gICAgbGV0IHByb2dyYW1GcmFtZSA9IHRoaXMucHVzaEZyYW1lKCk7XG5cbiAgICBpZiAoIXBhcmVudEZyYW1lKSB7XG4gICAgICBwcm9ncmFtWydzeW1ib2xzJ10gPSBTeW1ib2xUYWJsZS50b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3JhbVsnc3ltYm9scyddID0gcGFyZW50RnJhbWUuc3ltYm9scyEuY2hpbGQocHJvZ3JhbS5ibG9ja1BhcmFtcyk7XG4gICAgfVxuXG4gICAgbGV0IHN0YXJ0VHlwZTogc3RyaW5nLCBlbmRUeXBlOiBzdHJpbmc7XG5cbiAgICBpZiAodGhpcy5wcm9ncmFtRGVwdGggPT09IDApIHtcbiAgICAgIHN0YXJ0VHlwZSA9ICdzdGFydFByb2dyYW0nO1xuICAgICAgZW5kVHlwZSA9ICdlbmRQcm9ncmFtJztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUeXBlID0gJ3N0YXJ0QmxvY2snO1xuICAgICAgZW5kVHlwZSA9ICdlbmRCbG9jayc7XG4gICAgfVxuXG4gICAgcHJvZ3JhbUZyYW1lLnBhcmVudE5vZGUgPSBwcm9ncmFtO1xuICAgIHByb2dyYW1GcmFtZS5jaGlsZHJlbiA9IHByb2dyYW0uYm9keTtcbiAgICBwcm9ncmFtRnJhbWUuY2hpbGRDb3VudCA9IHByb2dyYW0uYm9keS5sZW5ndGg7XG4gICAgcHJvZ3JhbUZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMgPSBbXTtcbiAgICBwcm9ncmFtRnJhbWUuYWN0aW9ucy5wdXNoKFtlbmRUeXBlLCBbcHJvZ3JhbSwgdGhpcy5wcm9ncmFtRGVwdGhdXSBhcyBBY3Rpb24pO1xuICAgIHByb2dyYW1GcmFtZS5zeW1ib2xzID0gcHJvZ3JhbVsnc3ltYm9scyddO1xuXG4gICAgZm9yIChsZXQgaSA9IHByb2dyYW0uYm9keS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgcHJvZ3JhbUZyYW1lLmNoaWxkSW5kZXggPSBpO1xuICAgICAgdGhpcy52aXNpdChwcm9ncmFtLmJvZHlbaV0pO1xuICAgIH1cblxuICAgIHByb2dyYW1GcmFtZS5hY3Rpb25zLnB1c2goW3N0YXJ0VHlwZSwgW1xuICAgICAgcHJvZ3JhbSwgcHJvZ3JhbUZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudCxcbiAgICAgIHByb2dyYW1GcmFtZS5ibGFua0NoaWxkVGV4dE5vZGVzLnJldmVyc2UoKVxuICAgIF1dIGFzIEFjdGlvbik7XG4gICAgdGhpcy5wb3BGcmFtZSgpO1xuXG4gICAgdGhpcy5wcm9ncmFtRGVwdGgtLTtcblxuICAgIC8vIFB1c2ggdGhlIGNvbXBsZXRlZCB0ZW1wbGF0ZSBpbnRvIHRoZSBnbG9iYWwgYWN0aW9ucyBsaXN0XG4gICAgaWYgKHBhcmVudEZyYW1lKSB7IHBhcmVudEZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudCsrOyB9XG4gICAgdGhpcy5hY3Rpb25zLnB1c2goLi4ucHJvZ3JhbUZyYW1lLmFjdGlvbnMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIEVsZW1lbnROb2RlKGVsZW1lbnQ6IEFTVC5FbGVtZW50Tm9kZSkge1xuICAgIGxldCBwYXJlbnRGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGxldCBlbGVtZW50RnJhbWUgPSB0aGlzLnB1c2hGcmFtZSgpO1xuXG4gICAgZWxlbWVudEZyYW1lLnBhcmVudE5vZGUgPSBlbGVtZW50O1xuICAgIGVsZW1lbnRGcmFtZS5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgZWxlbWVudEZyYW1lLmNoaWxkQ291bnQgPSBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICBlbGVtZW50RnJhbWUubXVzdGFjaGVDb3VudCArPSBlbGVtZW50Lm1vZGlmaWVycy5sZW5ndGg7XG4gICAgZWxlbWVudEZyYW1lLmJsYW5rQ2hpbGRUZXh0Tm9kZXMgPSBbXTtcbiAgICBlbGVtZW50RnJhbWUuc3ltYm9scyA9IGVsZW1lbnRbJ3N5bWJvbHMnXSA9IHBhcmVudEZyYW1lLnN5bWJvbHMhLmNoaWxkKGVsZW1lbnQuYmxvY2tQYXJhbXMpO1xuXG4gICAgbGV0IGFjdGlvbkFyZ3M6IFtBU1QuRWxlbWVudE5vZGUsIG51bWJlciwgbnVtYmVyXSA9IFtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYXJlbnRGcmFtZS5jaGlsZEluZGV4ISxcbiAgICAgIHBhcmVudEZyYW1lLmNoaWxkQ291bnQhXG4gICAgXTtcblxuICAgIGVsZW1lbnRGcmFtZS5hY3Rpb25zLnB1c2goWydjbG9zZUVsZW1lbnQnLCBhY3Rpb25BcmdzXSk7XG5cbiAgICBmb3IgKGxldCBpID0gZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnZpc2l0KGVsZW1lbnQuYXR0cmlidXRlc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGVsZW1lbnRGcmFtZS5jaGlsZEluZGV4ID0gaTtcbiAgICAgIHRoaXMudmlzaXQoZWxlbWVudC5jaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgbGV0IG9wZW4gPSBbJ29wZW5FbGVtZW50JywgWy4uLmFjdGlvbkFyZ3MsIGVsZW1lbnRGcmFtZS5tdXN0YWNoZUNvdW50LCBlbGVtZW50RnJhbWUuYmxhbmtDaGlsZFRleHROb2Rlcy5yZXZlcnNlKCldXSBhcyBBY3Rpb24uT3BlbkVsZW1lbnQ7XG4gICAgZWxlbWVudEZyYW1lLmFjdGlvbnMucHVzaChvcGVuKTtcblxuICAgIHRoaXMucG9wRnJhbWUoKTtcblxuICAgIC8vIFByb3BhZ2F0ZSB0aGUgZWxlbWVudCdzIGZyYW1lIHN0YXRlIHRvIHRoZSBwYXJlbnQgZnJhbWVcbiAgICBpZiAoZWxlbWVudEZyYW1lLm11c3RhY2hlQ291bnQgPiAwKSB7IHBhcmVudEZyYW1lLm11c3RhY2hlQ291bnQrKzsgfVxuICAgIHBhcmVudEZyYW1lLmNoaWxkVGVtcGxhdGVDb3VudCArPSBlbGVtZW50RnJhbWUuY2hpbGRUZW1wbGF0ZUNvdW50O1xuICAgIHBhcmVudEZyYW1lLmFjdGlvbnMucHVzaCguLi5lbGVtZW50RnJhbWUuYWN0aW9ucyk7XG4gIH1cblxuICBBdHRyTm9kZShhdHRyOiBBU1QuQXR0ck5vZGUpIHtcbiAgICBpZiAoYXR0ci52YWx1ZS50eXBlICE9PSAnVGV4dE5vZGUnKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZS5tdXN0YWNoZUNvdW50Kys7XG4gICAgfVxuICB9O1xuXG4gIFRleHROb2RlKHRleHQ6IEFTVC5UZXh0Tm9kZSkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGlmICh0ZXh0LmNoYXJzID09PSAnJykge1xuICAgICAgZnJhbWUuYmxhbmtDaGlsZFRleHROb2RlcyEucHVzaChkb21JbmRleE9mKGZyYW1lLmNoaWxkcmVuISwgdGV4dCkpO1xuICAgIH1cbiAgICBmcmFtZS5hY3Rpb25zLnB1c2goWyd0ZXh0JywgW3RleHQsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuICB9O1xuXG4gIEJsb2NrU3RhdGVtZW50KG5vZGU6IEFTVC5CbG9ja1N0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXG4gICAgZnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ2Jsb2NrJywgW25vZGUsIGZyYW1lLmNoaWxkSW5kZXgsIGZyYW1lLmNoaWxkQ291bnRdXSBhcyBBY3Rpb24pO1xuXG4gICAgaWYgKG5vZGUuaW52ZXJzZSkgeyB0aGlzLnZpc2l0KG5vZGUuaW52ZXJzZSk7IH1cbiAgICBpZiAobm9kZS5wcm9ncmFtKSB7IHRoaXMudmlzaXQobm9kZS5wcm9ncmFtKTsgfVxuICB9O1xuXG4gIFBhcnRpYWxTdGF0ZW1lbnQobm9kZTogQVNULlBhcnRpYWxTdGF0ZW1lbnQpIHtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICBmcmFtZS5tdXN0YWNoZUNvdW50Kys7XG4gICAgZnJhbWUuYWN0aW9ucy5wdXNoKFsnbXVzdGFjaGUnLCBbbm9kZSwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG4gIH07XG5cbiAgQ29tbWVudFN0YXRlbWVudCh0ZXh0OiBBU1QuQ29tbWVudFN0YXRlbWVudCkge1xuICAgIGxldCBmcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ2NvbW1lbnQnLCBbdGV4dCwgZnJhbWUuY2hpbGRJbmRleCwgZnJhbWUuY2hpbGRDb3VudF1dIGFzIEFjdGlvbik7XG4gIH07XG5cbiAgTXVzdGFjaGVDb21tZW50U3RhdGVtZW50KCkge1xuICAgIC8vIEludGVudGlvbmFsIGVtcHR5OiBIYW5kbGViYXJzIGNvbW1lbnRzIHNob3VsZCBub3QgYWZmZWN0IG91dHB1dC5cbiAgfTtcblxuICBNdXN0YWNoZVN0YXRlbWVudChtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gICAgbGV0IGZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgZnJhbWUubXVzdGFjaGVDb3VudCsrO1xuICAgIGZyYW1lLmFjdGlvbnMucHVzaChbJ211c3RhY2hlJywgW211c3RhY2hlLCBmcmFtZS5jaGlsZEluZGV4LCBmcmFtZS5jaGlsZENvdW50XV0gYXMgQWN0aW9uKTtcbiAgfTtcblxuICAvLyBGcmFtZSBoZWxwZXJzXG5cbiAgcHJpdmF0ZSBnZXQgY3VycmVudEZyYW1lKCk6IEZyYW1lIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuZ2V0Q3VycmVudEZyYW1lKCksIFwiRXhwZWN0ZWQgYSBjdXJyZW50IGZyYW1lXCIpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDdXJyZW50RnJhbWUoKTogT3B0aW9uPEZyYW1lPiB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVTdGFja1t0aGlzLmZyYW1lU3RhY2subGVuZ3RoIC0gMV07XG4gIH1cblxuICBwcml2YXRlIHB1c2hGcmFtZSgpIHtcbiAgICBsZXQgZnJhbWUgPSBuZXcgRnJhbWUoKTtcbiAgICB0aGlzLmZyYW1lU3RhY2sucHVzaChmcmFtZSk7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3BGcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZVN0YWNrLnBvcCgpO1xuICB9XG59XG5cbi8vIFJldHVybnMgdGhlIGluZGV4IG9mIGBkb21Ob2RlYCBpbiB0aGUgYG5vZGVzYCBhcnJheSwgc2tpcHBpbmdcbi8vIG92ZXIgYW55IG5vZGVzIHdoaWNoIGRvIG5vdCByZXByZXNlbnQgRE9NIG5vZGVzLlxuZnVuY3Rpb24gZG9tSW5kZXhPZihub2RlczogQVNULk5vZGVbXSwgZG9tTm9kZTogQVNULlRleHROb2RlIHwgQVNULkVsZW1lbnROb2RlKSB7XG4gIGxldCBpbmRleCA9IC0xO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUudHlwZSAhPT0gJ1RleHROb2RlJyAmJiBub2RlLnR5cGUgIT09ICdFbGVtZW50Tm9kZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBkb21Ob2RlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuIiwiaW1wb3J0ICogYXMgV2lyZUZvcm1hdCBmcm9tICdAZ2xpbW1lci93aXJlLWZvcm1hdCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tIFwiQGdsaW1tZXIvdXRpbFwiO1xuaW1wb3J0IHsgU3RhY2ssIERpY3RTZXQsIE9wdGlvbiwgZXhwZWN0IH0gZnJvbSBcIkBnbGltbWVyL3V0aWxcIjtcbmltcG9ydCB7IEFTVCB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBCbG9ja1N5bWJvbFRhYmxlLCBQcm9ncmFtU3ltYm9sVGFibGUgfSBmcm9tICcuL3RlbXBsYXRlLXZpc2l0b3InO1xuXG5pbXBvcnQge1xuICBUZW1wbGF0ZU1ldGEsXG4gIFNlcmlhbGl6ZWRUZW1wbGF0ZUJsb2NrLFxuICBTZXJpYWxpemVkVGVtcGxhdGUsXG4gIENvcmUsXG4gIFN0YXRlbWVudCxcbiAgU3RhdGVtZW50cyxcbiAgRXhwcmVzc2lvbixcbiAgRXhwcmVzc2lvbnMsXG4gIE9wc1xufSBmcm9tICdAZ2xpbW1lci93aXJlLWZvcm1hdCc7XG5cbmV4cG9ydCB0eXBlIHN0ciA9IHN0cmluZztcbmV4cG9ydCB0eXBlIFBhcmFtcyA9IENvcmUuUGFyYW1zO1xuZXhwb3J0IHR5cGUgSGFzaCA9IENvcmUuSGFzaDtcbmV4cG9ydCB0eXBlIFBhdGggPSBDb3JlLlBhdGg7XG5leHBvcnQgdHlwZSBTdGFja1ZhbHVlID0gRXhwcmVzc2lvbiB8IFBhcmFtcyB8IEhhc2ggfCBzdHI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCbG9jayB7XG4gIHB1YmxpYyBzdGF0ZW1lbnRzOiBTdGF0ZW1lbnRbXSA9IFtdO1xuXG4gIGFic3RyYWN0IHRvSlNPTigpOiBPYmplY3Q7XG5cbiAgcHVzaChzdGF0ZW1lbnQ6IFN0YXRlbWVudCkge1xuICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIElubGluZUJsb2NrIGV4dGVuZHMgQmxvY2sge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFibGU6IEJsb2NrU3ltYm9sVGFibGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgdG9KU09OKCk6IFdpcmVGb3JtYXQuU2VyaWFsaXplZElubGluZUJsb2NrIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGVtZW50czogdGhpcy5zdGF0ZW1lbnRzLFxuICAgICAgcGFyYW1ldGVyczogdGhpcy50YWJsZS5zbG90c1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlQmxvY2sgZXh0ZW5kcyBCbG9jayB7XG4gIHB1YmxpYyB0eXBlID0gXCJ0ZW1wbGF0ZVwiO1xuICBwdWJsaWMgeWllbGRzID0gbmV3IERpY3RTZXQ8c3RyaW5nPigpO1xuICBwdWJsaWMgbmFtZWQgPSBuZXcgRGljdFNldDxzdHJpbmc+KCk7XG4gIHB1YmxpYyBibG9ja3M6IFdpcmVGb3JtYXQuU2VyaWFsaXplZElubGluZUJsb2NrW10gPSBbXTtcbiAgcHVibGljIGhhc0V2YWwgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN5bWJvbFRhYmxlOiBQcm9ncmFtU3ltYm9sVGFibGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHVzaChzdGF0ZW1lbnQ6IFN0YXRlbWVudCkge1xuICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gIH1cblxuICB0b0pTT04oKTogU2VyaWFsaXplZFRlbXBsYXRlQmxvY2sge1xuICAgIHJldHVybiB7XG4gICAgICBzeW1ib2xzOiB0aGlzLnN5bWJvbFRhYmxlLnN5bWJvbHMsXG4gICAgICBzdGF0ZW1lbnRzOiB0aGlzLnN0YXRlbWVudHMsXG4gICAgICBoYXNFdmFsOiB0aGlzLmhhc0V2YWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRCbG9jayBleHRlbmRzIEJsb2NrIHtcbiAgcHVibGljIGF0dHJpYnV0ZXM6IFN0YXRlbWVudHMuQXR0cmlidXRlW10gPSBbXTtcbiAgcHVibGljIGFyZ3VtZW50czogU3RhdGVtZW50cy5Bcmd1bWVudFtdID0gW107XG4gIHByaXZhdGUgaW5QYXJhbXMgPSB0cnVlO1xuICBwdWJsaWMgcG9zaXRpb25hbHM6IG51bWJlcltdID0gW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwdXNoKHN0YXRlbWVudDogU3RhdGVtZW50KSB7XG4gICAgaWYgKHRoaXMuaW5QYXJhbXMpIHtcbiAgICAgIGlmIChTdGF0ZW1lbnRzLmlzTW9kaWZpZXIoc3RhdGVtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBpbGUgRXJyb3I6IEVsZW1lbnQgbW9kaWZpZXJzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wb25lbnRzJyk7XG4gICAgICB9IGVsc2UgaWYgKFN0YXRlbWVudHMuaXNGbHVzaEVsZW1lbnQoc3RhdGVtZW50KSkge1xuICAgICAgICB0aGlzLmluUGFyYW1zID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKFN0YXRlbWVudHMuaXNBcmd1bWVudChzdGF0ZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuYXJndW1lbnRzLnB1c2goc3RhdGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoU3RhdGVtZW50cy5pc0F0dHJpYnV0ZShzdGF0ZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHN0YXRlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBpbGUgRXJyb3I6IG9ubHkgcGFyYW1ldGVycyBhbGxvd2VkIGJlZm9yZSBmbHVzaC1lbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCk6IFtXaXJlRm9ybWF0LlN0YXRlbWVudHMuQXR0cmlidXRlW10sIFdpcmVGb3JtYXQuQ29yZS5IYXNoLCBPcHRpb248V2lyZUZvcm1hdC5TZXJpYWxpemVkSW5saW5lQmxvY2s+XSB7XG4gICAgbGV0IGFyZ3MgPSB0aGlzLmFyZ3VtZW50cztcbiAgICBsZXQga2V5cyA9IGFyZ3MubWFwKGFyZyA9PiBhcmdbMV0pO1xuICAgIGxldCB2YWx1ZXMgPSBhcmdzLm1hcChhcmcgPT4gYXJnWzJdKTtcblxuICAgIHJldHVybiBbXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMsXG4gICAgICBba2V5cywgdmFsdWVzXSxcbiAgICAgIHtcbiAgICAgICAgc3RhdGVtZW50czogdGhpcy5zdGF0ZW1lbnRzLFxuICAgICAgICBwYXJhbWV0ZXJzOiB0aGlzLnRhYmxlLnNsb3RzXG4gICAgICB9XG4gICAgXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVtcGxhdGU8VCBleHRlbmRzIFRlbXBsYXRlTWV0YT4ge1xuICBwdWJsaWMgYmxvY2s6IFRlbXBsYXRlQmxvY2s7XG5cbiAgY29uc3RydWN0b3Ioc3ltYm9sczogUHJvZ3JhbVN5bWJvbFRhYmxlLCBwdWJsaWMgbWV0YTogVCkge1xuICAgIHRoaXMuYmxvY2sgPSBuZXcgVGVtcGxhdGVCbG9jayhzeW1ib2xzKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBTZXJpYWxpemVkVGVtcGxhdGU8VD4ge1xuICAgIHJldHVybiB7XG4gICAgICBibG9jazogdGhpcy5ibG9jay50b0pTT04oKSxcbiAgICAgIG1ldGE6IHRoaXMubWV0YVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSmF2YVNjcmlwdENvbXBpbGVyPFQgZXh0ZW5kcyBUZW1wbGF0ZU1ldGE+IHtcbiAgc3RhdGljIHByb2Nlc3M8VCBleHRlbmRzIFRlbXBsYXRlTWV0YT4ob3Bjb2RlczogYW55W10sIHN5bWJvbHM6IFByb2dyYW1TeW1ib2xUYWJsZSwgbWV0YTogVCk6IFRlbXBsYXRlPFQ+IHtcbiAgICBsZXQgY29tcGlsZXIgPSBuZXcgSmF2YVNjcmlwdENvbXBpbGVyPFQ+KG9wY29kZXMsIHN5bWJvbHMsIG1ldGEpO1xuICAgIHJldHVybiBjb21waWxlci5wcm9jZXNzKCk7XG4gIH1cblxuICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZTxUPjtcbiAgcHJpdmF0ZSBibG9ja3MgPSBuZXcgU3RhY2s8QmxvY2s+KCk7XG4gIHByaXZhdGUgb3Bjb2RlczogYW55W107XG4gIHByaXZhdGUgdmFsdWVzOiBTdGFja1ZhbHVlW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihvcGNvZGVzOiBhbnlbXSwgc3ltYm9sczogUHJvZ3JhbVN5bWJvbFRhYmxlLCBtZXRhOiBUKSB7XG4gICAgdGhpcy5vcGNvZGVzID0gb3Bjb2RlcztcbiAgICB0aGlzLnRlbXBsYXRlID0gbmV3IFRlbXBsYXRlKHN5bWJvbHMsIG1ldGEpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRCbG9jaygpOiBCbG9jayB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLmJsb2Nrcy5jdXJyZW50LCAnRXhwZWN0ZWQgYSBibG9jayBvbiB0aGUgc3RhY2snKTtcbiAgfVxuXG4gIHByb2Nlc3MoKTogVGVtcGxhdGU8VD4ge1xuICAgIHRoaXMub3Bjb2Rlcy5mb3JFYWNoKChbb3Bjb2RlLCAuLi5hcmdzXSkgPT4ge1xuICAgICAgaWYgKCF0aGlzW29wY29kZV0pIHsgdGhyb3cgbmV3IEVycm9yKGB1bmltcGxlbWVudGVkICR7b3Bjb2RlfSBvbiBKYXZhU2NyaXB0Q29tcGlsZXJgKTsgfVxuICAgICAgdGhpc1tvcGNvZGVdKC4uLmFyZ3MpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGU7XG4gIH1cblxuICAvLy8gTmVzdGluZ1xuXG4gIHN0YXJ0QmxvY2soW3Byb2dyYW1dOiBbQVNULlByb2dyYW1dKSB7XG4gICAgbGV0IGJsb2NrOiBCbG9jayA9IG5ldyBJbmxpbmVCbG9jayhwcm9ncmFtWydzeW1ib2xzJ10pO1xuICAgIHRoaXMuYmxvY2tzLnB1c2goYmxvY2spO1xuICB9XG5cbiAgZW5kQmxvY2soKSB7XG4gICAgbGV0IHsgdGVtcGxhdGUsIGJsb2NrcyB9ID0gdGhpcztcbiAgICBsZXQgYmxvY2sgPSBibG9ja3MucG9wKCkgYXMgSW5saW5lQmxvY2s7XG4gICAgdGVtcGxhdGUuYmxvY2suYmxvY2tzLnB1c2goYmxvY2sudG9KU09OKCkpO1xuICB9XG5cbiAgc3RhcnRQcm9ncmFtKCkge1xuICAgIHRoaXMuYmxvY2tzLnB1c2godGhpcy50ZW1wbGF0ZS5ibG9jayk7XG4gIH1cblxuICBlbmRQcm9ncmFtKCkge1xuXG4gIH1cblxuICAvLy8gU3RhdGVtZW50c1xuXG4gIHRleHQoY29udGVudDogc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuVGV4dCwgY29udGVudF0pO1xuICB9XG5cbiAgYXBwZW5kKHRydXN0ZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnB1c2goW09wcy5BcHBlbmQsIHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKSwgdHJ1c3RlZF0pO1xuICB9XG5cbiAgY29tbWVudCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5wdXNoKFtPcHMuQ29tbWVudCwgdmFsdWVdKTtcbiAgfVxuXG4gIG1vZGlmaWVyKG5hbWU6IHN0cmluZykge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKTtcbiAgICBsZXQgaGFzaCA9IHRoaXMucG9wVmFsdWU8SGFzaD4oKTtcblxuICAgIHRoaXMucHVzaChbT3BzLk1vZGlmaWVyLCBuYW1lLCBwYXJhbXMsIGhhc2hdKTtcbiAgfVxuXG4gIGJsb2NrKG5hbWU6IHN0cmluZywgdGVtcGxhdGU6IG51bWJlciwgaW52ZXJzZTogbnVtYmVyKSB7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMucG9wVmFsdWU8UGFyYW1zPigpO1xuICAgIGxldCBoYXNoID0gdGhpcy5wb3BWYWx1ZTxIYXNoPigpO1xuXG4gICAgbGV0IGJsb2NrcyA9IHRoaXMudGVtcGxhdGUuYmxvY2suYmxvY2tzO1xuICAgIGFzc2VydCh0eXBlb2YgdGVtcGxhdGUgIT09ICdudW1iZXInIHx8IGJsb2Nrc1t0ZW1wbGF0ZV0gIT09IG51bGwsICdtaXNzaW5nIGJsb2NrIGluIHRoZSBjb21waWxlcicpO1xuICAgIGFzc2VydCh0eXBlb2YgaW52ZXJzZSAhPT0gJ251bWJlcicgfHwgYmxvY2tzW2ludmVyc2VdICE9PSBudWxsLCAnbWlzc2luZyBibG9jayBpbiB0aGUgY29tcGlsZXInKTtcblxuICAgIHRoaXMucHVzaChbT3BzLkJsb2NrLCBuYW1lLCBwYXJhbXMsIGhhc2gsIGJsb2Nrc1t0ZW1wbGF0ZV0sIGJsb2Nrc1tpbnZlcnNlXV0pO1xuICB9XG5cbiAgb3BlblNwbGF0dGVkRWxlbWVudChlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICBsZXQgdGFnID0gZWxlbWVudC50YWc7XG5cbiAgICBpZiAoaXNDb21wb25lbnQodGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlIEVycm9yOiAuLi5hdHRyaWJ1dGVzIGNhbiBvbmx5IGJlIHVzZWQgaW4gYW4gZWxlbWVudGApO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5ibG9ja1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGUgRXJyb3I6IDwke2VsZW1lbnQudGFnfT4gaXMgbm90IGEgY29tcG9uZW50IGFuZCBkb2Vzbid0IHN1cHBvcnQgYmxvY2sgcGFyYW1ldGVyc2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2goW09wcy5PcGVuU3BsYXR0ZWRFbGVtZW50LCB0YWddKTtcbiAgICB9XG4gIH1cblxuICBvcGVuRWxlbWVudChlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICBsZXQgdGFnID0gZWxlbWVudC50YWc7XG5cbiAgICBpZiAoaXNDb21wb25lbnQodGFnKSkge1xuICAgICAgdGhpcy5zdGFydENvbXBvbmVudChlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQuYmxvY2tQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlIEVycm9yOiA8JHtlbGVtZW50LnRhZ30+IGlzIG5vdCBhIGNvbXBvbmVudCBhbmQgZG9lc24ndCBzdXBwb3J0IGJsb2NrIHBhcmFtZXRlcnNgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKFtPcHMuT3BlbkVsZW1lbnQsIHRhZ10pO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoRWxlbWVudCgpIHtcbiAgICB0aGlzLnB1c2goW09wcy5GbHVzaEVsZW1lbnRdKTtcbiAgfVxuXG4gIGNsb3NlRWxlbWVudChlbGVtZW50OiBBU1QuRWxlbWVudE5vZGUpIHtcbiAgICBsZXQgdGFnID0gZWxlbWVudC50YWc7XG5cbiAgICBpZiAoaXNDb21wb25lbnQodGFnKSkge1xuICAgICAgbGV0IFthdHRycywgYXJncywgYmxvY2tdID0gdGhpcy5lbmRDb21wb25lbnQoKTtcbiAgICAgIHRoaXMucHVzaChbT3BzLkNvbXBvbmVudCwgdGFnLCBhdHRycywgYXJncywgYmxvY2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKFtPcHMuQ2xvc2VFbGVtZW50XSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljQXR0cihuYW1lOiBzdHIsIG5hbWVzcGFjZTogc3RyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpO1xuICAgIHRoaXMucHVzaChbT3BzLlN0YXRpY0F0dHIsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdKTtcbiAgfVxuXG4gIGR5bmFtaWNBdHRyKG5hbWU6IHN0ciwgbmFtZXNwYWNlOiBzdHIpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuRHluYW1pY0F0dHIsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdKTtcbiAgfVxuXG4gIHRydXN0aW5nQXR0cihuYW1lOiBzdHIsIG5hbWVzcGFjZTogc3RyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5wb3BWYWx1ZTxFeHByZXNzaW9uPigpO1xuICAgIHRoaXMucHVzaChbT3BzLlRydXN0aW5nQXR0ciwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZV0pO1xuICB9XG5cbiAgc3RhdGljQXJnKG5hbWU6IHN0cikge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5TdGF0aWNBcmcsIG5hbWUsIHZhbHVlXSk7XG4gIH1cblxuICBkeW5hbWljQXJnKG5hbWU6IHN0cikge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMucG9wVmFsdWU8RXhwcmVzc2lvbj4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5EeW5hbWljQXJnLCBuYW1lLCB2YWx1ZV0pO1xuICB9XG5cbiAgeWllbGQodG86IG51bWJlcikge1xuICAgIGxldCBwYXJhbXMgPSB0aGlzLnBvcFZhbHVlPFBhcmFtcz4oKTtcbiAgICB0aGlzLnB1c2goW09wcy5ZaWVsZCwgdG8sIHBhcmFtc10pO1xuICB9XG5cbiAgYXR0clNwbGF0KHRvOiBudW1iZXIpIHtcbiAgICB0aGlzLnB1c2goW09wcy5BdHRyU3BsYXQsIHRvXSk7XG4gIH1cblxuICBkZWJ1Z2dlcihldmFsSW5mbzogQ29yZS5FdmFsSW5mbykge1xuICAgIHRoaXMucHVzaChbT3BzLkRlYnVnZ2VyLCBldmFsSW5mb10pO1xuICAgIHRoaXMudGVtcGxhdGUuYmxvY2suaGFzRXZhbCA9IHRydWU7XG4gIH1cblxuICBoYXNCbG9jayhuYW1lOiBudW1iZXIpIHtcbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5IYXNCbG9jaz4oW09wcy5IYXNCbG9jaywgbmFtZV0pO1xuICB9XG5cbiAgaGFzQmxvY2tQYXJhbXMobmFtZTogbnVtYmVyKSB7XG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuSGFzQmxvY2tQYXJhbXM+KFtPcHMuSGFzQmxvY2tQYXJhbXMsIG5hbWVdKTtcbiAgfVxuXG4gIHBhcnRpYWwoZXZhbEluZm86IENvcmUuRXZhbEluZm8pIHtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5wb3BWYWx1ZTxQYXJhbXM+KCk7XG4gICAgdGhpcy5wdXNoKFtPcHMuUGFydGlhbCwgcGFyYW1zWzBdLCBldmFsSW5mb10pO1xuICAgIHRoaXMudGVtcGxhdGUuYmxvY2suaGFzRXZhbCA9IHRydWU7XG4gIH1cblxuICAvLy8gRXhwcmVzc2lvbnNcblxuICBsaXRlcmFsKHZhbHVlOiBFeHByZXNzaW9ucy5WYWx1ZSB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5VbmRlZmluZWQ+KFtPcHMuVW5kZWZpbmVkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaFZhbHVlPEV4cHJlc3Npb25zLlZhbHVlPih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdW5rbm93bihuYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLnB1c2hWYWx1ZTxFeHByZXNzaW9ucy5Vbmtub3duPihbT3BzLlVua25vd24sIG5hbWVdKTtcbiAgfVxuXG4gIGdldChoZWFkOiBudW1iZXIsIHBhdGg6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuR2V0PihbT3BzLkdldCwgaGVhZCwgcGF0aF0pO1xuICB9XG5cbiAgbWF5YmVMb2NhbChwYXRoOiBzdHJpbmdbXSkge1xuICAgIHRoaXMucHVzaFZhbHVlPEV4cHJlc3Npb25zLk1heWJlTG9jYWw+KFtPcHMuTWF5YmVMb2NhbCwgcGF0aF0pO1xuICB9XG5cbiAgY29uY2F0KCkge1xuICAgIHRoaXMucHVzaFZhbHVlPEV4cHJlc3Npb25zLkNvbmNhdD4oW09wcy5Db25jYXQsIHRoaXMucG9wVmFsdWU8UGFyYW1zPigpXSk7XG4gIH1cblxuICBoZWxwZXIobmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IHBhcmFtcyA9IHRoaXMucG9wVmFsdWU8UGFyYW1zPigpO1xuICAgIGxldCBoYXNoID0gdGhpcy5wb3BWYWx1ZTxIYXNoPigpO1xuXG4gICAgdGhpcy5wdXNoVmFsdWU8RXhwcmVzc2lvbnMuSGVscGVyPihbT3BzLkhlbHBlciwgbmFtZSwgcGFyYW1zLCBoYXNoXSk7XG4gIH1cblxuICAvLy8gU3RhY2sgTWFuYWdlbWVudCBPcGNvZGVzXG5cbiAgc3RhcnRDb21wb25lbnQoZWxlbWVudDogQVNULkVsZW1lbnROb2RlKSB7XG4gICAgbGV0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnRCbG9jayhlbGVtZW50WydzeW1ib2xzJ10pO1xuICAgIHRoaXMuYmxvY2tzLnB1c2goY29tcG9uZW50KTtcbiAgfVxuXG4gIGVuZENvbXBvbmVudCgpOiBbV2lyZUZvcm1hdC5TdGF0ZW1lbnRzLkF0dHJpYnV0ZVtdLCBXaXJlRm9ybWF0LkNvcmUuSGFzaCwgT3B0aW9uPFdpcmVGb3JtYXQuU2VyaWFsaXplZElubGluZUJsb2NrPl0ge1xuICAgIGxldCBjb21wb25lbnQgPSB0aGlzLmJsb2Nrcy5wb3AoKTtcbiAgICBhc3NlcnQoY29tcG9uZW50IGluc3RhbmNlb2YgQ29tcG9uZW50QmxvY2ssIFwiQ29tcGlsZXIgYnVnOiBlbmRDb21wb25lbnQoKSBzaG91bGQgZW5kIGEgY29tcG9uZW50XCIpO1xuICAgIHJldHVybiAoY29tcG9uZW50IGFzIENvbXBvbmVudEJsb2NrKS50b0pTT04oKTtcbiAgfVxuXG4gIHByZXBhcmVBcnJheShzaXplOiBudW1iZXIpIHtcbiAgICBsZXQgdmFsdWVzOiBFeHByZXNzaW9uW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaCh0aGlzLnBvcFZhbHVlKCkgYXMgRXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoVmFsdWU8UGFyYW1zPih2YWx1ZXMpO1xuICB9XG5cbiAgcHJlcGFyZU9iamVjdChzaXplOiBudW1iZXIpIHtcbiAgICBhc3NlcnQodGhpcy52YWx1ZXMubGVuZ3RoID49IHNpemUsIGBFeHBlY3RlZCAke3NpemV9IHZhbHVlcyBvbiB0aGUgc3RhY2ssIGZvdW5kICR7dGhpcy52YWx1ZXMubGVuZ3RofWApO1xuXG4gICAgbGV0IGtleXM6IHN0cmluZ1tdID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGxldCB2YWx1ZXM6IEV4cHJlc3Npb25bXSA9IG5ldyBBcnJheShzaXplKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBrZXlzW2ldID0gdGhpcy5wb3BWYWx1ZTxzdHI+KCk7XG4gICAgICB2YWx1ZXNbaV0gPSB0aGlzLnBvcFZhbHVlPEV4cHJlc3Npb24+KCk7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoVmFsdWU8SGFzaD4oW2tleXMsIHZhbHVlc10pO1xuICB9XG5cbiAgLy8vIFV0aWxpdGllc1xuXG4gIHB1c2goYXJnczogU3RhdGVtZW50KSB7XG4gICAgd2hpbGUgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuICAgICAgYXJncy5wb3AoKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRCbG9jay5wdXNoKGFyZ3MpO1xuICB9XG5cbiAgcHVzaFZhbHVlPFMgZXh0ZW5kcyBFeHByZXNzaW9uIHwgUGFyYW1zIHwgSGFzaD4odmFsOiBTKSB7XG4gICAgdGhpcy52YWx1ZXMucHVzaCh2YWwpO1xuICB9XG5cbiAgcG9wVmFsdWU8VCBleHRlbmRzIFN0YWNrVmFsdWU+KCk6IFQge1xuICAgIGFzc2VydCh0aGlzLnZhbHVlcy5sZW5ndGgsIFwiTm8gZXhwcmVzc2lvbiBmb3VuZCBvbiBzdGFja1wiKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXMucG9wKCkgYXMgVDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbXBvbmVudCh0YWc6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBsZXQgb3BlbiA9IHRhZy5jaGFyQXQoMCk7XG5cbiAgcmV0dXJuIG9wZW4gPT09IG9wZW4udG9VcHBlckNhc2UoKTtcbn0iLCJleHBvcnQgZnVuY3Rpb24gcHJvY2Vzc09wY29kZXMoY29tcGlsZXI6IGFueSwgb3Bjb2RlczogYW55KSB7XG4gIGZvciAobGV0IGk9MCwgbD1vcGNvZGVzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICBsZXQgbWV0aG9kID0gb3Bjb2Rlc1tpXVswXTtcbiAgICBsZXQgcGFyYW1zID0gb3Bjb2Rlc1tpXVsxXTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBjb21waWxlclttZXRob2RdLmFwcGx5KGNvbXBpbGVyLCBwYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21waWxlclttZXRob2RdLmNhbGwoY29tcGlsZXIpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGVyZSBpcyBhIHNtYWxsIHdoaXRlbGlzdCBvZiBuYW1lc3BhY2VkIGF0dHJpYnV0ZXMgc3BlY2lhbGx5XG4vLyBlbnVtZXJhdGVkIGluXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbC9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTBcbi8vXG4vLyA+IFdoZW4gYSBmb3JlaWduIGVsZW1lbnQgaGFzIG9uZSBvZiB0aGUgbmFtZXNwYWNlZCBhdHRyaWJ1dGVzIGdpdmVuIGJ5XG4vLyA+IHRoZSBsb2NhbCBuYW1lIGFuZCBuYW1lc3BhY2Ugb2YgdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2VsbHMgb2YgYSByb3dcbi8vID4gZnJvbSB0aGUgZm9sbG93aW5nIHRhYmxlLCBpdCBtdXN0IGJlIHdyaXR0ZW4gdXNpbmcgdGhlIG5hbWUgZ2l2ZW4gYnlcbi8vID4gdGhlIHRoaXJkIGNlbGwgZnJvbSB0aGUgc2FtZSByb3cuXG4vL1xuLy8gSW4gYWxsIG90aGVyIGNhc2VzLCBjb2xvbnMgYXJlIGludGVycHJldGVkIGFzIGEgcmVndWxhciBjaGFyYWN0ZXJcbi8vIHdpdGggbm8gc3BlY2lhbCBtZWFuaW5nOlxuLy9cbi8vID4gTm8gb3RoZXIgbmFtZXNwYWNlZCBhdHRyaWJ1dGUgY2FuIGJlIGV4cHJlc3NlZCBpbiB0aGUgSFRNTCBzeW50YXguXG5cbmNvbnN0IFhMSU5LID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuY29uc3QgWE1MID0gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc7XG5jb25zdCBYTUxOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLyc7XG5cbmNvbnN0IFdISVRFTElTVCA9IHtcbiAgJ3hsaW5rOmFjdHVhdGUnOiBYTElOSyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiBYTElOSyxcbiAgJ3hsaW5rOmhyZWYnOiBYTElOSyxcbiAgJ3hsaW5rOnJvbGUnOiBYTElOSyxcbiAgJ3hsaW5rOnNob3cnOiBYTElOSyxcbiAgJ3hsaW5rOnRpdGxlJzogWExJTkssXG4gICd4bGluazp0eXBlJzogWExJTkssXG4gICd4bWw6YmFzZSc6IFhNTCxcbiAgJ3htbDpsYW5nJzogWE1MLFxuICAneG1sOnNwYWNlJzogWE1MLFxuICAneG1sbnMnOiBYTUxOUyxcbiAgJ3htbG5zOnhsaW5rJzogWE1MTlNcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBdHRyTmFtZXNwYWNlKGF0dHJOYW1lOiBzdHJpbmcpIHtcbiAgcmV0dXJuIFdISVRFTElTVFthdHRyTmFtZV0gfHwgbnVsbDtcbn1cbiIsImltcG9ydCBUZW1wbGF0ZVZpc2l0b3IsIHsgU3ltYm9sVGFibGUsIEFjdGlvbiB9IGZyb20gXCIuL3RlbXBsYXRlLXZpc2l0b3JcIjtcbmltcG9ydCBKYXZhU2NyaXB0Q29tcGlsZXIsIHsgVGVtcGxhdGUgfSBmcm9tIFwiLi9qYXZhc2NyaXB0LWNvbXBpbGVyXCI7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gXCJAZ2xpbW1lci91dGlsXCI7XG5pbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCB9IGZyb20gXCJAZ2xpbW1lci91dGlsXCI7XG5pbXBvcnQgeyBUZW1wbGF0ZU1ldGEgfSBmcm9tIFwiQGdsaW1tZXIvd2lyZS1mb3JtYXRcIjtcbmltcG9ydCB7IEFTVCwgaXNMaXRlcmFsLCBTeW50YXhFcnJvciB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBnZXRBdHRyTmFtZXNwYWNlIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGlsZU9wdGlvbnM8VCBleHRlbmRzIFRlbXBsYXRlTWV0YT4ge1xuICBtZXRhOiBUO1xufVxuXG5mdW5jdGlvbiBpc1RydXN0ZWRWYWx1ZSh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB2YWx1ZS5lc2NhcGVkICE9PSB1bmRlZmluZWQgJiYgIXZhbHVlLmVzY2FwZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbXBsYXRlQ29tcGlsZXI8VCBleHRlbmRzIFRlbXBsYXRlTWV0YT4ge1xuICBzdGF0aWMgY29tcGlsZTxUIGV4dGVuZHMgVGVtcGxhdGVNZXRhPihvcHRpb25zOiBDb21waWxlT3B0aW9uczxUPiwgYXN0OiBBU1QuUHJvZ3JhbSk6IFRlbXBsYXRlPFQ+IHtcbiAgICBsZXQgdGVtcGxhdGVWaXNpdG9yID0gbmV3IFRlbXBsYXRlVmlzaXRvcigpO1xuICAgIHRlbXBsYXRlVmlzaXRvci52aXNpdChhc3QpO1xuXG4gICAgbGV0IGNvbXBpbGVyID0gbmV3IFRlbXBsYXRlQ29tcGlsZXIob3B0aW9ucyk7XG4gICAgbGV0IG9wY29kZXMgPSBjb21waWxlci5wcm9jZXNzKHRlbXBsYXRlVmlzaXRvci5hY3Rpb25zKTtcbiAgICByZXR1cm4gSmF2YVNjcmlwdENvbXBpbGVyLnByb2Nlc3M8VD4ob3Bjb2RlcywgYXN0WydzeW1ib2xzJ10sIG9wdGlvbnMubWV0YSk7XG4gIH1cblxuICBwcml2YXRlIG9wdGlvbnM6IENvbXBpbGVPcHRpb25zPFQ+O1xuICBwcml2YXRlIHRlbXBsYXRlSWQgPSAwO1xuICBwcml2YXRlIHRlbXBsYXRlSWRzOiBudW1iZXJbXSA9IFtdO1xuICBwcml2YXRlIHN5bWJvbFN0YWNrID0gbmV3IFN0YWNrPFN5bWJvbFRhYmxlPigpO1xuICBwcml2YXRlIG9wY29kZXM6IGFueVtdID0gW107XG4gIHByaXZhdGUgaW5jbHVkZU1ldGEgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDb21waWxlT3B0aW9uczxUPikge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIH1cblxuICBnZXQgc3ltYm9scygpOiBTeW1ib2xUYWJsZSB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLnN5bWJvbFN0YWNrLmN1cnJlbnQsICdFeHBlY3RlZCBhIHN5bWJvbCB0YWJsZSBvbiB0aGUgc3RhY2snKTtcbiAgfVxuXG4gIHByb2Nlc3MoYWN0aW9uczogQWN0aW9uW10pOiBBY3Rpb25bXSB7XG4gICAgYWN0aW9ucy5mb3JFYWNoKChbbmFtZSwgLi4uYXJnc10pID0+IHtcbiAgICAgIGlmICghdGhpc1tuYW1lXSkgeyB0aHJvdyBuZXcgRXJyb3IoYFVuaW1wbGVtZW50ZWQgJHtuYW1lfSBvbiBUZW1wbGF0ZUNvbXBpbGVyYCk7IH1cbiAgICAgICh0aGlzW25hbWVdIGFzIGFueSkoLi4uYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMub3Bjb2RlcztcbiAgfVxuXG4gIHN0YXJ0UHJvZ3JhbShwcm9ncmFtOiBbQVNULlByb2dyYW1dKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wdXNoKHByb2dyYW1bMF1bJ3N5bWJvbHMnXSk7XG4gICAgdGhpcy5vcGNvZGUoJ3N0YXJ0UHJvZ3JhbScsIHByb2dyYW0sIHByb2dyYW0pO1xuICB9XG5cbiAgZW5kUHJvZ3JhbSgpIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnBvcCgpO1xuICAgIHRoaXMub3Bjb2RlKCdlbmRQcm9ncmFtJywgbnVsbCk7XG4gIH1cblxuICBzdGFydEJsb2NrKHByb2dyYW06IFtBU1QuUHJvZ3JhbV0pIHtcbiAgICB0aGlzLnN5bWJvbFN0YWNrLnB1c2gocHJvZ3JhbVswXVsnc3ltYm9scyddKTtcbiAgICB0aGlzLnRlbXBsYXRlSWQrKztcbiAgICB0aGlzLm9wY29kZSgnc3RhcnRCbG9jaycsIHByb2dyYW0sIHByb2dyYW0pO1xuICB9XG5cbiAgZW5kQmxvY2soKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgICB0aGlzLnRlbXBsYXRlSWRzLnB1c2godGhpcy50ZW1wbGF0ZUlkIC0gMSk7XG4gICAgdGhpcy5vcGNvZGUoJ2VuZEJsb2NrJywgbnVsbCk7XG4gIH1cblxuICB0ZXh0KFthY3Rpb25dOiBbQVNULlRleHROb2RlXSkge1xuICAgIHRoaXMub3Bjb2RlKCd0ZXh0JywgYWN0aW9uLCBhY3Rpb24uY2hhcnMpO1xuICB9XG5cbiAgY29tbWVudChbYWN0aW9uXTogW0FTVC5Db21tZW50U3RhdGVtZW50XSkge1xuICAgIHRoaXMub3Bjb2RlKCdjb21tZW50JywgYWN0aW9uLCBhY3Rpb24udmFsdWUpO1xuICB9XG5cbiAgb3BlbkVsZW1lbnQoW2FjdGlvbl06IFtBU1QuRWxlbWVudE5vZGVdKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBhY3Rpb24uYXR0cmlidXRlcztcbiAgICBsZXQgaGFzU3BsYXQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgIGlmIChhdHRyLm5hbWUgPT09ICcuLi5hdHRyaWJ1dGVzJykge1xuICAgICAgICBoYXNTcGxhdCA9IGF0dHI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNTcGxhdCkge1xuICAgICAgdGhpcy5vcGNvZGUoJ29wZW5TcGxhdHRlZEVsZW1lbnQnLCBhY3Rpb24sIGFjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdvcGVuRWxlbWVudCcsIGFjdGlvbiwgYWN0aW9uKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbi5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZShbYWN0aW9uLmF0dHJpYnV0ZXNbaV1dKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbi5tb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMubW9kaWZpZXIoW2FjdGlvbi5tb2RpZmllcnNbaV1dKTtcbiAgICB9XG4gICAgdGhpcy5vcGNvZGUoJ2ZsdXNoRWxlbWVudCcsIG51bGwpO1xuICAgIHRoaXMuc3ltYm9sU3RhY2sucHVzaChhY3Rpb25bJ3N5bWJvbHMnXSk7XG4gIH1cblxuICBjbG9zZUVsZW1lbnQoW2FjdGlvbl06IFtBU1QuRWxlbWVudE5vZGVdKSB7XG4gICAgdGhpcy5zeW1ib2xTdGFjay5wb3AoKTtcbiAgICB0aGlzLm9wY29kZSgnY2xvc2VFbGVtZW50JywgbnVsbCwgYWN0aW9uKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZShbYWN0aW9uXTogW0FTVC5BdHRyTm9kZV0pIHtcbiAgICBsZXQgeyBuYW1lLCB2YWx1ZSB9ID0gYWN0aW9uO1xuXG4gICAgbGV0IG5hbWVzcGFjZSA9IGdldEF0dHJOYW1lc3BhY2UobmFtZSk7XG5cbiAgICBsZXQgaXNTdGF0aWMgPSB0aGlzLnByZXBhcmVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSk7XG5cbiAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgLy8gQXJndW1lbnRzXG4gICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoJ3N0YXRpY0FyZycsIGFjdGlvbiwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvbi52YWx1ZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnKSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKCdkeW5hbWljQXJnJywgYWN0aW9uLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKCdkeW5hbWljQXJnJywgYWN0aW9uLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGlzVHJ1c3RpbmcgPSBpc1RydXN0ZWRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChpc1N0YXRpYyAmJiBuYW1lID09PSAnLi4uYXR0cmlidXRlcycpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoJ2F0dHJTcGxhdCcsIGFjdGlvbiwgdGhpcy5zeW1ib2xzLmFsbG9jYXRlQmxvY2soJ2F0dHJzJykpO1xuICAgICAgfSBlbHNlIGlmIChpc1N0YXRpYykge1xuICAgICAgICB0aGlzLm9wY29kZSgnc3RhdGljQXR0cicsIGFjdGlvbiwgbmFtZSwgbmFtZXNwYWNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUcnVzdGluZykge1xuICAgICAgICB0aGlzLm9wY29kZSgndHJ1c3RpbmdBdHRyJywgYWN0aW9uLCBuYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgfSBlbHNlIGlmIChhY3Rpb24udmFsdWUudHlwZSA9PT0gJ011c3RhY2hlU3RhdGVtZW50Jykge1xuICAgICAgICB0aGlzLm9wY29kZSgnZHluYW1pY0F0dHInLCBhY3Rpb24sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoJ2R5bmFtaWNBdHRyJywgYWN0aW9uLCBuYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG1vZGlmaWVyKFthY3Rpb25dOiBbQVNULkVsZW1lbnRNb2RpZmllclN0YXRlbWVudF0pIHtcbiAgICBhc3NlcnRJc1NpbXBsZVBhdGgoYWN0aW9uLnBhdGgsIGFjdGlvbi5sb2MsICdtb2RpZmllcicpO1xuXG4gICAgbGV0IHsgcGF0aDogeyBwYXJ0cyB9IH0gPSBhY3Rpb247XG5cbiAgICB0aGlzLnByZXBhcmVIZWxwZXIoYWN0aW9uKTtcbiAgICB0aGlzLm9wY29kZSgnbW9kaWZpZXInLCBhY3Rpb24sIHBhcnRzWzBdKTtcbiAgfVxuXG4gIG11c3RhY2hlKFthY3Rpb25dOiBbQVNULk11c3RhY2hlU3RhdGVtZW50XSkge1xuICAgIGxldCB7IHBhdGggfSA9IGFjdGlvbjtcblxuICAgIGlmIChpc0xpdGVyYWwocGF0aCkpIHtcbiAgICAgIHRoaXMubXVzdGFjaGVFeHByZXNzaW9uKGFjdGlvbik7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kJywgYWN0aW9uLCAhYWN0aW9uLmVzY2FwZWQpO1xuICAgIH0gZWxzZSBpZiAoaXNZaWVsZChwYXRoKSkge1xuICAgICAgbGV0IHRvID0gYXNzZXJ0VmFsaWRZaWVsZChhY3Rpb24pO1xuICAgICAgdGhpcy55aWVsZCh0bywgYWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzUGFydGlhbChwYXRoKSkge1xuICAgICAgbGV0IHBhcmFtcyA9IGFzc2VydFZhbGlkUGFydGlhbChhY3Rpb24pO1xuICAgICAgdGhpcy5wYXJ0aWFsKHBhcmFtcywgYWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVidWdnZXIocGF0aCkpIHtcbiAgICAgIGFzc2VydFZhbGlkRGVidWdnZXJVc2FnZShhY3Rpb24pO1xuICAgICAgdGhpcy5kZWJ1Z2dlcignZGVidWdnZXInLCBhY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm11c3RhY2hlRXhwcmVzc2lvbihhY3Rpb24pO1xuICAgICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcsIGFjdGlvbiwgIWFjdGlvbi5lc2NhcGVkKTtcbiAgICB9XG4gIH1cblxuICBibG9jayhbYWN0aW9uLyosIGluZGV4LCBjb3VudCovXTogW0FTVC5CbG9ja1N0YXRlbWVudF0pIHtcbiAgICB0aGlzLnByZXBhcmVIZWxwZXIoYWN0aW9uKTtcbiAgICBsZXQgdGVtcGxhdGVJZCA9IHRoaXMudGVtcGxhdGVJZHMucG9wKCk7XG4gICAgbGV0IGludmVyc2VJZCA9IGFjdGlvbi5pbnZlcnNlID09PSBudWxsID8gbnVsbCA6IHRoaXMudGVtcGxhdGVJZHMucG9wKCk7XG4gICAgdGhpcy5vcGNvZGUoJ2Jsb2NrJywgYWN0aW9uLCBhY3Rpb24ucGF0aC5wYXJ0c1swXSwgdGVtcGxhdGVJZCwgaW52ZXJzZUlkKTtcbiAgfVxuXG4gIC8vLyBJbnRlcm5hbCBhY3Rpb25zLCBub3QgZm91bmQgaW4gdGhlIG9yaWdpbmFsIHByb2Nlc3NlZCBhY3Rpb25zXG5cbiAgYXJnKFtwYXRoXTogW0FTVC5QYXRoRXhwcmVzc2lvbl0pIHtcbiAgICBsZXQgeyBwYXJ0czogW2hlYWQsIC4uLnJlc3RdIH0gPSBwYXRoO1xuICAgIGxldCBzeW1ib2wgPSB0aGlzLnN5bWJvbHMuYWxsb2NhdGVOYW1lZChoZWFkKTtcbiAgICB0aGlzLm9wY29kZSgnZ2V0JywgcGF0aCwgc3ltYm9sLCByZXN0KTtcbiAgfVxuXG4gIG11c3RhY2hlRXhwcmVzc2lvbihleHByOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyBwYXRoIH0gPSBleHByO1xuXG4gICAgaWYgKGlzTGl0ZXJhbChwYXRoKSkge1xuICAgICAgdGhpcy5vcGNvZGUoJ2xpdGVyYWwnLCBleHByLCBwYXRoLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQnVpbHRJbkhlbHBlcihwYXRoKSkge1xuICAgICAgdGhpcy5idWlsdEluSGVscGVyKGV4cHIgYXMgQVNULkNhbGwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcmcocGF0aCkpIHtcbiAgICAgIHRoaXMuYXJnKFtwYXRoXSk7XG4gICAgfSBlbHNlIGlmIChpc0hlbHBlckludm9jYXRpb24oZXhwcikpIHtcbiAgICAgIHRoaXMucHJlcGFyZUhlbHBlcihleHByKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdoZWxwZXInLCBleHByLCBwYXRoLnBhcnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHBhdGgudGhpcykge1xuICAgICAgdGhpcy5vcGNvZGUoJ2dldCcsIGV4cHIsIDAsIHBhdGgucGFydHMpO1xuICAgIH0gZWxzZSBpZiAoaXNMb2NhbChwYXRoLCB0aGlzLnN5bWJvbHMpKSB7XG4gICAgICBsZXQgW2hlYWQsIC4uLnBhcnRzXSA9IHBhdGgucGFydHM7XG4gICAgICB0aGlzLm9wY29kZSgnZ2V0JywgZXhwciwgdGhpcy5zeW1ib2xzLmdldChoZWFkKSwgcGFydHMpO1xuICAgIH0gZWxzZSBpZiAoaXNTaW1wbGVQYXRoKHBhdGgpKSB7XG4gICAgICB0aGlzLm9wY29kZSgndW5rbm93bicsIGV4cHIsIHBhdGgucGFydHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wY29kZSgnbWF5YmVMb2NhbCcsIGV4cHIsIHBhdGgucGFydHMpO1xuICAgIH1cbiAgfVxuXG4gIC8vLyBJbnRlcm5hbCBTeW50YXhcblxuICB5aWVsZCh0bzogc3RyaW5nLCBhY3Rpb246IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIHRoaXMucHJlcGFyZVBhcmFtcyhhY3Rpb24ucGFyYW1zKTtcbiAgICB0aGlzLm9wY29kZSgneWllbGQnLCBhY3Rpb24sIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKHRvKSk7XG4gIH1cblxuICBkZWJ1Z2dlcihfbmFtZTogc3RyaW5nLCBhY3Rpb246IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICAgIHRoaXMub3Bjb2RlKCdkZWJ1Z2dlcicsIGFjdGlvbiwgdGhpcy5zeW1ib2xzLmdldEV2YWxJbmZvKCkpO1xuICB9XG5cbiAgaGFzQmxvY2sobmFtZTogc3RyaW5nLCBhY3Rpb246IEFTVC5DYWxsKSB7XG4gICAgdGhpcy5vcGNvZGUoJ2hhc0Jsb2NrJywgYWN0aW9uLCB0aGlzLnN5bWJvbHMuYWxsb2NhdGVCbG9jayhuYW1lKSk7XG4gIH1cblxuICBoYXNCbG9ja1BhcmFtcyhuYW1lOiBzdHJpbmcsIGFjdGlvbjogQVNULkNhbGwpIHtcbiAgICB0aGlzLm9wY29kZSgnaGFzQmxvY2tQYXJhbXMnLCBhY3Rpb24sIHRoaXMuc3ltYm9scy5hbGxvY2F0ZUJsb2NrKG5hbWUpKTtcbiAgfVxuXG4gIHBhcnRpYWwoX3BhcmFtczogQVNULkV4cHJlc3Npb25bXSwgYWN0aW9uOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICB0aGlzLnByZXBhcmVQYXJhbXMoYWN0aW9uLnBhcmFtcyk7XG4gICAgdGhpcy5vcGNvZGUoJ3BhcnRpYWwnLCBhY3Rpb24sIHRoaXMuc3ltYm9scy5nZXRFdmFsSW5mbygpKTtcbiAgfVxuXG4gIGJ1aWx0SW5IZWxwZXIoZXhwcjogQVNULkNhbGwpIHtcbiAgICBsZXQgeyBwYXRoIH0gPSBleHByO1xuICAgIGlmIChpc0hhc0Jsb2NrKHBhdGgpKSB7XG4gICAgICBsZXQgbmFtZSA9IGFzc2VydFZhbGlkSGFzQmxvY2tVc2FnZShleHByLnBhdGgub3JpZ2luYWwsIGV4cHIpO1xuICAgICAgdGhpcy5oYXNCbG9jayhuYW1lLCBleHByKTtcbiAgICB9IGVsc2UgaWYgKGlzSGFzQmxvY2tQYXJhbXMocGF0aCkpIHtcbiAgICAgIGxldCBuYW1lID0gYXNzZXJ0VmFsaWRIYXNCbG9ja1VzYWdlKGV4cHIucGF0aC5vcmlnaW5hbCwgZXhwcik7XG4gICAgICB0aGlzLmhhc0Jsb2NrUGFyYW1zKG5hbWUsIGV4cHIpO1xuICAgIH1cbiAgfVxuXG4gIC8vLyBFeHByZXNzaW9ucywgaW52b2tlZCByZWN1cnNpdmVseSBmcm9tIHByZXBhcmVQYXJhbXMgYW5kIHByZXBhcmVIYXNoXG5cbiAgU3ViRXhwcmVzc2lvbihleHByOiBBU1QuU3ViRXhwcmVzc2lvbikge1xuICAgIGlmIChpc0J1aWx0SW5IZWxwZXIoZXhwci5wYXRoKSkge1xuICAgICAgdGhpcy5idWlsdEluSGVscGVyKGV4cHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZXBhcmVIZWxwZXIoZXhwcik7XG4gICAgICB0aGlzLm9wY29kZSgnaGVscGVyJywgZXhwciwgZXhwci5wYXRoLnBhcnRzWzBdKTtcbiAgICB9XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihleHByOiBBU1QuUGF0aEV4cHJlc3Npb24pIHtcbiAgICBpZiAoZXhwci5kYXRhKSB7XG4gICAgICB0aGlzLmFyZyhbZXhwcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgeyBzeW1ib2xzIH0gPSB0aGlzO1xuICAgICAgbGV0IFtoZWFkXSA9IGV4cHIucGFydHM7XG5cbiAgICAgIGlmIChleHByLnRoaXMpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoJ2dldCcsIGV4cHIsIDAsIGV4cHIucGFydHMpO1xuICAgICAgfSBlbHNlICBpZiAoc3ltYm9scy5oYXMoaGVhZCkpIHtcbiAgICAgICAgdGhpcy5vcGNvZGUoJ2dldCcsIGV4cHIsIHN5bWJvbHMuZ2V0KGhlYWQpLCBleHByLnBhcnRzLnNsaWNlKDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3Bjb2RlKCdnZXQnLCBleHByLCAwLCBleHByLnBhcnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBTdHJpbmdMaXRlcmFsKGFjdGlvbjogQVNULlN0cmluZ0xpdGVyYWwpIHtcbiAgICB0aGlzLm9wY29kZSgnbGl0ZXJhbCcsIG51bGwsIGFjdGlvbi52YWx1ZSk7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChhY3Rpb246IEFTVC5Cb29sZWFuTGl0ZXJhbCkge1xuICAgIHRoaXMub3Bjb2RlKCdsaXRlcmFsJywgbnVsbCwgYWN0aW9uLnZhbHVlKTtcbiAgfVxuXG4gIE51bWJlckxpdGVyYWwoYWN0aW9uOiBBU1QuTnVtYmVyTGl0ZXJhbCkge1xuICAgIHRoaXMub3Bjb2RlKCdsaXRlcmFsJywgbnVsbCwgYWN0aW9uLnZhbHVlKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKGFjdGlvbjogQVNULk51bGxMaXRlcmFsKSB7XG4gICAgdGhpcy5vcGNvZGUoJ2xpdGVyYWwnLCBudWxsLCBhY3Rpb24udmFsdWUpO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbChhY3Rpb246IEFTVC5VbmRlZmluZWRMaXRlcmFsKSB7XG4gICAgdGhpcy5vcGNvZGUoJ2xpdGVyYWwnLCBudWxsLCBhY3Rpb24udmFsdWUpO1xuICB9XG5cbiAgLy8vIFV0aWxpdGllc1xuXG4gIG9wY29kZShuYW1lOiBhbnksIGFjdGlvbjogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuICAgIGxldCBvcGNvZGUgPSBbbmFtZSwgLi4uYXJnc107XG4gICAgaWYgKHRoaXMuaW5jbHVkZU1ldGEgJiYgYWN0aW9uKSB7XG4gICAgICBvcGNvZGUucHVzaCh0aGlzLm1ldGEoYWN0aW9uKSk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGVzLnB1c2gob3Bjb2RlKTtcbiAgfVxuXG4gIHByZXBhcmVIZWxwZXIoZXhwcjogQVNULkNhbGwpIHtcbiAgICBhc3NlcnRJc1NpbXBsZVBhdGgoZXhwci5wYXRoLCBleHByLmxvYywgJ2hlbHBlcicpO1xuXG4gICAgbGV0IHsgcGFyYW1zLCBoYXNoIH0gPSBleHByO1xuXG4gICAgdGhpcy5wcmVwYXJlSGFzaChoYXNoKTtcbiAgICB0aGlzLnByZXBhcmVQYXJhbXMocGFyYW1zKTtcbiAgfVxuXG4gIHByZXBhcmVQYXJhbXMocGFyYW1zOiBBU1QuRXhwcmVzc2lvbltdKSB7XG4gICAgaWYgKCFwYXJhbXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9wY29kZSgnbGl0ZXJhbCcsIG51bGwsIG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBwYXJhbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBwYXJhbSA9IHBhcmFtc1tpXTtcblxuICAgICAgYXNzZXJ0KHRoaXNbcGFyYW0udHlwZV0sIGBVbmltcGxlbWVudGVkICR7cGFyYW0udHlwZX0gb24gVGVtcGxhdGVDb21waWxlcmApO1xuICAgICAgKHRoaXNbcGFyYW0udHlwZV0gYXMgYW55KShwYXJhbSk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGUoJ3ByZXBhcmVBcnJheScsIG51bGwsIHBhcmFtcy5sZW5ndGgpO1xuICB9XG5cbiAgcHJlcGFyZUhhc2goaGFzaDogQVNULkhhc2gpIHtcbiAgICBsZXQgcGFpcnMgPSBoYXNoLnBhaXJzO1xuXG4gICAgaWYgKCFwYWlycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdsaXRlcmFsJywgbnVsbCwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IHBhaXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgeyBrZXksIHZhbHVlIH0gPSBwYWlyc1tpXTtcblxuICAgICAgYXNzZXJ0KHRoaXNbdmFsdWUudHlwZV0sIGBVbmltcGxlbWVudGVkICR7dmFsdWUudHlwZX0gb24gVGVtcGxhdGVDb21waWxlcmApO1xuICAgICAgKHRoaXNbdmFsdWUudHlwZV0gYXMgYW55KSh2YWx1ZSk7XG4gICAgICB0aGlzLm9wY29kZSgnbGl0ZXJhbCcsIG51bGwsIGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGUoJ3ByZXBhcmVPYmplY3QnLCBudWxsLCBwYWlycy5sZW5ndGgpO1xuICB9XG5cbiAgcHJlcGFyZUF0dHJpYnV0ZVZhbHVlKHZhbHVlOiBBU1QuQXR0ck5vZGVbJ3ZhbHVlJ10pIHtcbiAgICAvLyByZXR1cm5zIHRoZSBzdGF0aWMgdmFsdWUgaWYgdGhlIHZhbHVlIGlzIHN0YXRpY1xuXG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICBjYXNlICdUZXh0Tm9kZSc6XG4gICAgICAgIHRoaXMub3Bjb2RlKCdsaXRlcmFsJywgdmFsdWUsIHZhbHVlLmNoYXJzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdNdXN0YWNoZVN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTXVzdGFjaGUoW3ZhbHVlXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGNhc2UgJ0NvbmNhdFN0YXRlbWVudCc6XG4gICAgICAgIHRoaXMucHJlcGFyZUNvbmNhdFBhcnRzKHZhbHVlLnBhcnRzKTtcbiAgICAgICAgdGhpcy5vcGNvZGUoJ2NvbmNhdCcsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVDb25jYXRQYXJ0cyhwYXJ0czogQVNULkNvbmNhdFN0YXRlbWVudFsncGFydHMnXSkge1xuICAgIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ011c3RhY2hlU3RhdGVtZW50Jykge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU11c3RhY2hlKFtwYXJ0XSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gJ1RleHROb2RlJykge1xuICAgICAgICB0aGlzLm9wY29kZSgnbGl0ZXJhbCcsIG51bGwsIHBhcnQuY2hhcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3Bjb2RlKCdwcmVwYXJlQXJyYXknLCBudWxsLCBwYXJ0cy5sZW5ndGgpO1xuICB9XG5cbiAgYXR0cmlidXRlTXVzdGFjaGUoW2FjdGlvbl06IFtBU1QuTXVzdGFjaGVTdGF0ZW1lbnRdKSB7XG4gICAgdGhpcy5tdXN0YWNoZUV4cHJlc3Npb24oYWN0aW9uKTtcbiAgfVxuXG4gIG1ldGEobm9kZTogQVNULkJhc2VOb2RlKSB7XG4gICAgbGV0IGxvYyA9IG5vZGUubG9jO1xuICAgIGlmICghbG9jKSB7IHJldHVybiBbXTsgfVxuXG4gICAgbGV0IHsgc291cmNlLCBzdGFydCwgZW5kIH0gPSBsb2M7XG4gICAgcmV0dXJuIFsgJ2xvYycsIFtzb3VyY2UgfHwgbnVsbCwgW3N0YXJ0LmxpbmUsIHN0YXJ0LmNvbHVtbl0sIFtlbmQubGluZSwgZW5kLmNvbHVtbl1dIF07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNIZWxwZXJJbnZvY2F0aW9uKG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpOiBtdXN0YWNoZSBpcyBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQgJiB7IHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbiB9IHtcbiAgcmV0dXJuIChtdXN0YWNoZS5wYXJhbXMgJiYgbXVzdGFjaGUucGFyYW1zLmxlbmd0aCA+IDApIHx8XG4gICAgKG11c3RhY2hlLmhhc2ggJiYgbXVzdGFjaGUuaGFzaC5wYWlycy5sZW5ndGggPiAwKTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVQYXRoKHsgcGFydHMgfTogQVNULlBhdGhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDE7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwoeyBwYXJ0cyB9OiBBU1QuUGF0aEV4cHJlc3Npb24sIHN5bWJvbHM6IFN5bWJvbFRhYmxlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzeW1ib2xzICYmIC8qIHBhcnRzLmxlbmd0aCAmJiAqLyBzeW1ib2xzLmhhcyhwYXJ0c1swXSk7XG59XG5cbmZ1bmN0aW9uIGlzWWllbGQocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAneWllbGQnO1xufVxuXG5mdW5jdGlvbiBpc1BhcnRpYWwocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAncGFydGlhbCc7XG59XG5cbmZ1bmN0aW9uIGlzRGVidWdnZXIocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAnZGVidWdnZXInO1xufVxuXG5mdW5jdGlvbiBpc0hhc0Jsb2NrKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbikge1xuICByZXR1cm4gcGF0aC5vcmlnaW5hbCA9PT0gJ2hhcy1ibG9jayc7XG59XG5cbmZ1bmN0aW9uIGlzSGFzQmxvY2tQYXJhbXMocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKSB7XG4gIHJldHVybiBwYXRoLm9yaWdpbmFsID09PSAnaGFzLWJsb2NrLXBhcmFtcyc7XG59XG5cbmZ1bmN0aW9uIGlzQnVpbHRJbkhlbHBlcihwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24pIHtcbiAgcmV0dXJuIGlzSGFzQmxvY2socGF0aCkgfHwgaXNIYXNCbG9ja1BhcmFtcyhwYXRoKTtcbn1cblxuZnVuY3Rpb24gaXNBcmcocGF0aDogQVNULlBhdGhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIXBhdGhbJ2RhdGEnXTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNTaW1wbGVQYXRoKHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbiwgbG9jOiBBU1QuU291cmNlTG9jYXRpb24sIGNvbnRleHQ6IHN0cmluZykge1xuICBpZiAoIWlzU2ltcGxlUGF0aChwYXRoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgXFxgJHtwYXRoLm9yaWdpbmFsfVxcYCBpcyBub3QgYSB2YWxpZCBuYW1lIGZvciBhICR7Y29udGV4dH0gb24gbGluZSAke2xvYy5zdGFydC5saW5lfS5gLCBwYXRoLmxvYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRZaWVsZChzdGF0ZW1lbnQ6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCk6IHN0cmluZyB7XG4gIGxldCB7IHBhaXJzIH0gPSBzdGF0ZW1lbnQuaGFzaDtcblxuICBpZiAoKHBhaXJzLmxlbmd0aCA9PT0gMSAmJiBwYWlyc1swXS5rZXkgIT09ICd0bycpIHx8IHBhaXJzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYHlpZWxkIG9ubHkgdGFrZXMgYSBzaW5nbGUgbmFtZWQgYXJndW1lbnQ6ICd0bydgLCBzdGF0ZW1lbnQubG9jKTtcbiAgfSBlbHNlIGlmIChwYWlycy5sZW5ndGggPT09IDEgJiYgcGFpcnNbMF0udmFsdWUudHlwZSAhPT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGB5b3UgY2FuIG9ubHkgeWllbGQgdG8gYSBsaXRlcmFsIHZhbHVlYCwgc3RhdGVtZW50LmxvYyk7XG4gIH0gZWxzZSBpZiAocGFpcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHBhaXJzWzBdLnZhbHVlIGFzIEFTVC5TdHJpbmdMaXRlcmFsKS52YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFBhcnRpYWwoc3RhdGVtZW50OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIC8qIDogZXhwciAqLyB7XG4gIGxldCB7IHBhcmFtcywgaGFzaCwgZXNjYXBlZCwgbG9jIH0gPSBzdGF0ZW1lbnQ7XG5cbiAgaWYgKHBhcmFtcyAmJiBwYXJhbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBQYXJ0aWFsIGZvdW5kIHdpdGggbm8gYXJndW1lbnRzLiBZb3UgbXVzdCBzcGVjaWZ5IGEgdGVtcGxhdGUgbmFtZS4gKG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0pYCwgc3RhdGVtZW50LmxvYyk7XG4gIH0gZWxzZSBpZiAoaGFzaCAmJiBoYXNoLnBhaXJzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYHBhcnRpYWwgZG9lcyBub3QgdGFrZSBhbnkgbmFtZWQgYXJndW1lbnRzIChvbiBsaW5lICR7bG9jLnN0YXJ0LmxpbmV9KWAsIHN0YXRlbWVudC5sb2MpO1xuICB9IGVsc2UgaWYgKCFlc2NhcGVkKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGB7e3twYXJ0aWFsIC4uLn19fSBpcyBub3Qgc3VwcG9ydGVkLCBwbGVhc2UgdXNlIHt7cGFydGlhbCAuLi59fSBpbnN0ZWFkIChvbiBsaW5lICR7bG9jLnN0YXJ0LmxpbmV9KWAsIHN0YXRlbWVudC5sb2MpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRIYXNCbG9ja1VzYWdlKHR5cGU6IHN0cmluZywgY2FsbDogQVNULkNhbGwpOiBzdHJpbmcge1xuICBsZXQgeyBwYXJhbXMsIGhhc2gsIGxvYyB9ID0gY2FsbDtcblxuICBpZiAoaGFzaCAmJiBoYXNoLnBhaXJzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYCR7dHlwZX0gZG9lcyBub3QgdGFrZSBhbnkgbmFtZWQgYXJndW1lbnRzYCwgY2FsbC5sb2MpO1xuICB9XG5cbiAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQnO1xuICB9IGVsc2UgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgcGFyYW0gPSBwYXJhbXNbMF07XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdTdHJpbmdMaXRlcmFsJykge1xuICAgICAgcmV0dXJuIHBhcmFtLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYHlvdSBjYW4gb25seSB5aWVsZCB0byBhIGxpdGVyYWwgdmFsdWUgKG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0pYCwgY2FsbC5sb2MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYCR7dHlwZX0gb25seSB0YWtlcyBhIHNpbmdsZSBwb3NpdGlvbmFsIGFyZ3VtZW50IChvbiBsaW5lICR7bG9jLnN0YXJ0LmxpbmV9KWAsIGNhbGwubG9jKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZERlYnVnZ2VyVXNhZ2Uoc3RhdGVtZW50OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgbGV0IHsgcGFyYW1zLCBoYXNoIH0gPSBzdGF0ZW1lbnQ7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5wYWlycy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBkZWJ1Z2dlciBkb2VzIG5vdCB0YWtlIGFueSBuYW1lZCBhcmd1bWVudHNgLCBzdGF0ZW1lbnQubG9jKTtcbiAgfVxuXG4gIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdkZWZhdWx0JztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYGRlYnVnZ2VyIGRvZXMgbm90IHRha2UgYW55IHBvc2l0aW9uYWwgYXJndW1lbnRzYCwgc3RhdGVtZW50LmxvYyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IHByZXByb2Nlc3MgfSBmcm9tIFwiQGdsaW1tZXIvc3ludGF4XCI7XG5pbXBvcnQgVGVtcGxhdGVDb21waWxlciwgeyBDb21waWxlT3B0aW9ucyB9IGZyb20gXCIuL3RlbXBsYXRlLWNvbXBpbGVyXCI7XG5pbXBvcnQgeyBTZXJpYWxpemVkVGVtcGxhdGVXaXRoTGF6eUJsb2NrLCBUZW1wbGF0ZUphdmFzY3JpcHQsIFRlbXBsYXRlTWV0YSB9IGZyb20gXCJAZ2xpbW1lci93aXJlLWZvcm1hdFwiO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSBcIkBnbGltbWVyL2ludGVyZmFjZXNcIjtcbmltcG9ydCB7IFByZXByb2Nlc3NPcHRpb25zIH0gZnJvbSBcIkBnbGltbWVyL3N5bnRheFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlSWRGbiB7XG4gIChzcmM6IHN0cmluZyk6IE9wdGlvbjxzdHJpbmc+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWNvbXBpbGVPcHRpb25zPFQgZXh0ZW5kcyBUZW1wbGF0ZU1ldGE+IGV4dGVuZHMgQ29tcGlsZU9wdGlvbnM8VD4sIFByZXByb2Nlc3NPcHRpb25zIHtcbiAgaWQ/OiBUZW1wbGF0ZUlkRm47XG59XG5cbmRlY2xhcmUgZnVuY3Rpb24gcmVxdWlyZShpZDogc3RyaW5nKTogYW55O1xuXG5jb25zdCBkZWZhdWx0SWQ6IFRlbXBsYXRlSWRGbiA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1yZXF1aXJlLWltcG9ydHMgKi9cbiAgICAgIGNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1yZXF1aXJlLWltcG9ydHMgKi9cblxuICAgICAgbGV0IGlkRm46IFRlbXBsYXRlSWRGbiA9IHNyYyA9PiB7XG4gICAgICAgIGxldCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICAgICAgaGFzaC51cGRhdGUoc3JjLCAndXRmOCcpO1xuICAgICAgICAvLyB0cmltIHRvIDYgYnl0ZXMgb2YgZGF0YSAoMl40OCAtIDEpXG4gICAgICAgIHJldHVybiBoYXNoLmRpZ2VzdCgnYmFzZTY0Jykuc3Vic3RyaW5nKDAsOCk7XG4gICAgICB9O1xuXG4gICAgICBpZEZuKFwidGVzdFwiKTtcblxuICAgICAgcmV0dXJuIGlkRm47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBpZEZuKCkgeyByZXR1cm4gbnVsbDsgfTtcbn0pKCk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zOiBQcmVjb21waWxlT3B0aW9uczxUZW1wbGF0ZU1ldGE+ID0ge1xuICBpZDogZGVmYXVsdElkLFxuICBtZXRhOiB7fVxufTtcblxuLypcbiAqIENvbXBpbGUgYSBzdHJpbmcgaW50byBhIHRlbXBsYXRlIGphdmFzY3JpcHQgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U6XG4gKiAgICAgaW1wb3J0IHsgcHJlY29tcGlsZSB9IGZyb20gJ0BnbGltbWVyL2NvbXBpbGVyJztcbiAqICAgICBpbXBvcnQgeyB0ZW1wbGF0ZUZhY3RvcnkgfSBmcm9tICdnbGltZXItcnVudGltZSc7XG4gKiAgICAgbGV0IHRlbXBsYXRlSnMgPSBwcmVjb21waWxlKFwiSG93ZHkge3tuYW1lfX1cIik7XG4gKiAgICAgbGV0IGZhY3RvcnkgPSB0ZW1wbGF0ZUZhY3RvcnkobmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgdGVtcGxhdGVKcykoKSk7XG4gKiAgICAgbGV0IHRlbXBsYXRlID0gZmFjdG9yeS5jcmVhdGUoZW52KTtcbiAqXG4gKiBAbWV0aG9kIHByZWNvbXBpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgYSBHbGltbWVyIHRlbXBsYXRlIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfSBhIHRlbXBsYXRlIGphdmFzY3JpcHQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVjb21waWxlPFQgZXh0ZW5kcyBUZW1wbGF0ZU1ldGE+KHN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogUHJlY29tcGlsZU9wdGlvbnM8VD4pOiBUZW1wbGF0ZUphdmFzY3JpcHQ7XG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcGlsZShzdHJpbmc6IHN0cmluZywgb3B0aW9uczogUHJlY29tcGlsZU9wdGlvbnM8VGVtcGxhdGVNZXRhPiA9IGRlZmF1bHRPcHRpb25zKTogVGVtcGxhdGVKYXZhc2NyaXB0IHtcbiAgbGV0IGFzdCA9IHByZXByb2Nlc3Moc3RyaW5nLCBvcHRpb25zKTtcbiAgbGV0IHsgYmxvY2ssIG1ldGEgfSA9IFRlbXBsYXRlQ29tcGlsZXIuY29tcGlsZShvcHRpb25zLCBhc3QpO1xuICBsZXQgaWRGbiA9IG9wdGlvbnMuaWQgfHwgZGVmYXVsdElkO1xuICBsZXQgYmxvY2tKU09OID0gSlNPTi5zdHJpbmdpZnkoYmxvY2sudG9KU09OKCkpO1xuICBsZXQgdGVtcGxhdGVKU09OT2JqZWN0OiBTZXJpYWxpemVkVGVtcGxhdGVXaXRoTGF6eUJsb2NrPFRlbXBsYXRlTWV0YT4gPSB7XG4gICAgaWQ6IGlkRm4oSlNPTi5zdHJpbmdpZnkobWV0YSkgKyBibG9ja0pTT04pLFxuICAgIGJsb2NrOiBibG9ja0pTT04sXG4gICAgbWV0YVxuICB9O1xuXG4gIC8vIEpTT04gaXMgamF2YXNjcmlwdFxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGVtcGxhdGVKU09OT2JqZWN0KTtcbn1cbiJdLCJuYW1lcyI6WyJkaWN0IiwidW5yZWFjaGFibGUiLCJEaWN0U2V0IiwiU3RhdGVtZW50cyIsIlN0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
