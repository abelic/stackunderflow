function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import b from "../builders";
import { appendChild, isLiteral, printLiteral } from "../utils";
import { Parser } from '../parser';
import SyntaxError from '../errors/syntax-error';
export var HandlebarsNodeVisitors = function (_Parser) {
    _inherits(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
        _classCallCheck(this, HandlebarsNodeVisitors);

        return _possibleConstructorReturn(this, _Parser.apply(this, arguments));
    }

    HandlebarsNodeVisitors.prototype.Program = function Program(program) {
        var body = [];
        var node = b.program(body, program.blockParams, program.loc);
        var i = void 0,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        var poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            var elementNode = poppedNode;
            throw new SyntaxError("Unclosed element `" + elementNode.tag + "` (on line " + elementNode.loc.start.line + ").", elementNode.loc);
        }
        return node;
    };

    HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new SyntaxError("A block may only be used inside an HTML element or another block.", block.loc);
        }

        var _acceptCallNodes = acceptCallNodes(this, block),
            path = _acceptCallNodes.path,
            params = _acceptCallNodes.params,
            hash = _acceptCallNodes.hash;

        var program = this.Program(block.program);
        var inverse = block.inverse ? this.Program(block.inverse) : null;
        var node = b.block(path, params, hash, program, inverse, block.loc);
        var parentProgram = this.currentElement();
        appendChild(parentProgram, node);
    };

    HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
        var tokenizer = this.tokenizer;

        if (tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        var mustache = void 0;
        var escaped = rawMustache.escaped,
            loc = rawMustache.loc;

        if (rawMustache.path.type.match(/Literal$/)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: b.hash(),
                escaped: escaped,
                loc: loc
            };
        } else {
            var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                path = _acceptCallNodes2.path,
                params = _acceptCallNodes2.params,
                hash = _acceptCallNodes2.hash;

            mustache = b.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer.state) {
            // Tag helpers
            case "tagName":
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.state = "beforeAttributeName";
                break;
            case "beforeAttributeName":
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName":
            case "afterAttributeName":
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.state = "beforeAttributeName";
                break;
            case "afterAttributeValueQuoted":
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.state = "beforeAttributeName";
                break;
            // Attribute values
            case "beforeAttributeValue":
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer.state = 'attributeValueUnquoted';
                break;
            case "attributeValueDoubleQuoted":
            case "attributeValueSingleQuoted":
            case "attributeValueUnquoted":
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                appendChild(this.currentElement(), mustache);
        }
        return mustache;
    };

    HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    };

    HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawComment));
            return null;
        }
        var value = rawComment.value,
            loc = rawComment.loc;

        var comment = b.mustacheComment(value, loc);
        switch (tokenizer.state) {
            case "beforeAttributeName":
                this.currentStartTag.comments.push(comment);
                break;
            case 'beforeData':
            case 'data':
                appendChild(this.currentElement(), comment);
                break;
            default:
                throw new SyntaxError("Using a Handlebars comment when in the `" + tokenizer.state + "` state is not supported: \"" + comment.value + "\" on line " + loc.start.line + ":" + loc.start.column, rawComment.loc);
        }
        return comment;
    };

    HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
        var loc = partial.loc;

        throw new SyntaxError("Handlebars partials are not supported: \"" + this.sourceForNode(partial, partial.name) + "\" at L" + loc.start.line + ":C" + loc.start.column, partial.loc);
    };

    HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
        var loc = partialBlock.loc;

        throw new SyntaxError("Handlebars partial blocks are not supported: \"" + this.sourceForNode(partialBlock, partialBlock.name) + "\" at L" + loc.start.line + ":C" + loc.start.column, partialBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
        var loc = decorator.loc;

        throw new SyntaxError("Handlebars decorators are not supported: \"" + this.sourceForNode(decorator, decorator.path) + "\" at L" + loc.start.line + ":C" + loc.start.column, decorator.loc);
    };

    HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
        var loc = decoratorBlock.loc;

        throw new SyntaxError("Handlebars decorator blocks are not supported: \"" + this.sourceForNode(decoratorBlock, decoratorBlock.path) + "\" at L" + loc.start.line + ":C" + loc.start.column, decoratorBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
        var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
            path = _acceptCallNodes3.path,
            params = _acceptCallNodes3.params,
            hash = _acceptCallNodes3.hash;

        return b.sexpr(path, params, hash, sexpr.loc);
    };

    HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
        var original = path.original,
            loc = path.loc;

        var parts = void 0;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new SyntaxError("Using \"./\" is not supported in Glimmer and unnecessary: \"" + path.original + "\" on line " + loc.start.line + ".", path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new SyntaxError("Changing context using \"../\" is not supported in Glimmer: \"" + path.original + "\" on line " + loc.start.line + ".", path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new SyntaxError("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths: \"" + path.original + "\" on line " + loc.start.line + ".", path.loc);
            }
            parts = [path.parts.join('/')];
        } else {
            parts = path.parts;
        }
        var thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping – such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts: parts,
            data: path.data,
            loc: path.loc
        };
    };

    HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
        var pairs = [];
        for (var i = 0; i < hash.pairs.length; i++) {
            var pair = hash.pairs[i];
            pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return b.hash(pairs, hash.loc);
    };

    HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
        return b.literal('StringLiteral', string.value, string.loc);
    };

    HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
        return b.literal('BooleanLiteral', boolean.value, boolean.loc);
    };

    HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
        return b.literal('NumberLiteral', number.value, number.loc);
    };

    HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
        return b.literal('UndefinedLiteral', undefined, undef.loc);
    };

    HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
        return b.literal('NullLiteral', null, nul.loc);
    };

    return HandlebarsNodeVisitors;
}(Parser);
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split("\n").length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    var path = compiler.PathExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
        return compiler.acceptNode(e);
    }) : [];
    var hash = node.hash ? compiler.Hash(node.hash) : b.hash();
    return { path: path, params: params, hash: hash };
}
function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if (isLiteral(path)) {
        var _modifier = "{{" + printLiteral(path) + "}}";
        var tag = "<" + element.name + " ... " + _modifier + " ...";
        throw new SyntaxError("In " + tag + ", " + _modifier + " is not a valid modifier: \"" + path.original + "\" on line " + (loc && loc.start.line) + ".", mustache.loc);
    }
    var modifier = b.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIvaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsT0FBTyxBQUFDLE9BQU0sQUFBYSxBQUFDO0FBQzVCLEFBQU8sU0FBRSxBQUFXLGFBQUUsQUFBUyxXQUFFLEFBQVksQUFBRSxvQkFBTSxBQUFVLEFBQUM7QUFHaEUsQUFBTyxTQUFFLEFBQU0sQUFBa0IsY0FBTSxBQUFXLEFBQUM7QUFDbkQsT0FBTyxBQUFXLGlCQUFNLEFBQXdCLEFBQUM7QUFJakQsQUFBTSxXQUF1Qzs7Ozs7Ozs7O2dFQUtuQyxBQUE4QixTQUNwQztZQUFJLEFBQUksT0FBb0IsQUFBRSxBQUFDLEFBQy9CO1lBQUksQUFBSSxPQUFHLEFBQUMsRUFBQyxBQUFPLFFBQUMsQUFBSSxNQUFFLEFBQU8sUUFBQyxBQUFXLGFBQUUsQUFBTyxRQUFDLEFBQUcsQUFBQyxBQUFDLEFBQzdEO1lBQUksQUFBQztZQUFFLEFBQUMsSUFBRyxBQUFPLFFBQUMsQUFBSSxLQUFDLEFBQU0sQUFBQyxBQUUvQixBQUFJO2FBQUMsQUFBWSxhQUFDLEFBQUksS0FBQyxBQUFJLEFBQUMsQUFBQyxBQUU3QixBQUFFLEFBQUM7WUFBQyxBQUFDLE1BQUssQUFBQyxBQUFDLEdBQUMsQUFBQyxBQUFDLEFBQU07bUJBQUMsQUFBSSxLQUFDLEFBQVksYUFBQyxBQUFHLEFBQWlCLEFBQUMsQUFBQyxBQUFDO0FBRS9ELEFBQUcsQUFBQzthQUFDLEFBQUMsSUFBRyxBQUFDLEdBQUUsQUFBQyxJQUFHLEFBQUMsR0FBRSxBQUFDLEFBQUUsS0FBRSxBQUFDLEFBQ3ZCLEFBQUk7aUJBQUMsQUFBVSxXQUFDLEFBQU8sUUFBQyxBQUFJLEtBQUMsQUFBQyxBQUFDLEFBQUMsQUFBQyxBQUNu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QUFBSSxLQUFDLEFBQVEsQUFBQyxBQUFDLEFBQ25DLEFBQUM7O0FBRUQseUNBQXlDLEFBQW9CLFdBQUUsQUFBMkIsTUFDeEYsQUFBUztjQUFDLEFBQVMsWUFBRyxBQUFJLEFBQUMsQUFDM0IsQUFBUztjQUFDLEFBQUssTUFBQyxBQUFJLEtBQUMsQUFBSSxBQUFDLEFBQUMsQUFDN0IsQUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiIGZyb20gXCIuLi9idWlsZGVyc1wiO1xuaW1wb3J0IHsgYXBwZW5kQ2hpbGQsIGlzTGl0ZXJhbCwgcHJpbnRMaXRlcmFsIH0gZnJvbSBcIi4uL3V0aWxzXCI7XG5pbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0ICogYXMgSGFuZGxlYmFyc0FTVCBmcm9tICcuLi90eXBlcy9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgeyBQYXJzZXIsIFRhZywgQXR0cmlidXRlIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCBTeW50YXhFcnJvciBmcm9tICcuLi9lcnJvcnMvc3ludGF4LWVycm9yJztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gXCJAZ2xpbW1lci91dGlsXCI7XG5pbXBvcnQgeyBSZWNhc3QgfSBmcm9tIFwiQGdsaW1tZXIvaW50ZXJmYWNlc1wiO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyBleHRlbmRzIFBhcnNlciB7XG4gIGFic3RyYWN0IGFwcGVuZFRvQ29tbWVudERhdGEoczogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hBdHRyaWJ1dGVWYWx1ZSgpOiB2b2lkO1xuXG4gIFByb2dyYW0ocHJvZ3JhbTogSGFuZGxlYmFyc0FTVC5Qcm9ncmFtKTogQVNULlByb2dyYW0ge1xuICAgIGxldCBib2R5OiBBU1QuU3RhdGVtZW50W10gPSBbXTtcbiAgICBsZXQgbm9kZSA9IGIucHJvZ3JhbShib2R5LCBwcm9ncmFtLmJsb2NrUGFyYW1zLCBwcm9ncmFtLmxvYyk7XG4gICAgbGV0IGksIGwgPSBwcm9ncmFtLmJvZHkubGVuZ3RoO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChub2RlKTtcblxuICAgIGlmIChsID09PSAwKSB7IHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1QuUHJvZ3JhbTsgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5hY2NlcHROb2RlKHByb2dyYW0uYm9keVtpXSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhhdCB0aGUgZWxlbWVudCBzdGFjayBpcyBiYWxhbmNlZCBwcm9wZXJseS5cbiAgICBsZXQgcG9wcGVkTm9kZSA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChwb3BwZWROb2RlICE9PSBub2RlKSB7XG4gICAgICBsZXQgZWxlbWVudE5vZGUgPSBwb3BwZWROb2RlIGFzIEFTVC5FbGVtZW50Tm9kZTtcblxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5jbG9zZWQgZWxlbWVudCBgXCIgKyBlbGVtZW50Tm9kZS50YWcgKyBcImAgKG9uIGxpbmUgXCIgKyBlbGVtZW50Tm9kZS5sb2MhLnN0YXJ0LmxpbmUgKyBcIikuXCIsIGVsZW1lbnROb2RlLmxvYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBCbG9ja1N0YXRlbWVudChibG9jazogSGFuZGxlYmFyc0FTVC5CbG9ja1N0YXRlbWVudCkge1xuICAgIGlmICh0aGlzLnRva2VuaXplclsnc3RhdGUnXSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKGJsb2NrKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW5pemVyWydzdGF0ZSddICE9PSAnY29tbWVudCcgJiYgdGhpcy50b2tlbml6ZXJbJ3N0YXRlJ10gIT09ICdkYXRhJyAmJiB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2JlZm9yZURhdGEnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBIGJsb2NrIG1heSBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZWxlbWVudCBvciBhbm90aGVyIGJsb2NrLlwiLCBibG9jay5sb2MpO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIGJsb2NrKTtcbiAgICBsZXQgcHJvZ3JhbSA9IHRoaXMuUHJvZ3JhbShibG9jay5wcm9ncmFtKTtcbiAgICBsZXQgaW52ZXJzZSA9IGJsb2NrLmludmVyc2UgPyB0aGlzLlByb2dyYW0oYmxvY2suaW52ZXJzZSkgOiBudWxsO1xuXG4gICAgbGV0IG5vZGUgPSBiLmJsb2NrKHBhdGgsIHBhcmFtcywgaGFzaCwgcHJvZ3JhbSwgaW52ZXJzZSwgYmxvY2subG9jKTtcbiAgICBsZXQgcGFyZW50UHJvZ3JhbSA9IHRoaXMuY3VycmVudEVsZW1lbnQoKTtcbiAgICBhcHBlbmRDaGlsZChwYXJlbnRQcm9ncmFtLCBub2RlKTtcbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KHJhd011c3RhY2hlOiBIYW5kbGViYXJzQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplclsnc3RhdGUnXSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd011c3RhY2hlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQ7XG4gICAgbGV0IHsgZXNjYXBlZCwgbG9jIH0gPSByYXdNdXN0YWNoZTtcblxuICAgIGlmIChyYXdNdXN0YWNoZS5wYXRoLnR5cGUubWF0Y2goL0xpdGVyYWwkLykpIHtcbiAgICAgIG11c3RhY2hlID0ge1xuICAgICAgICB0eXBlOiAnTXVzdGFjaGVTdGF0ZW1lbnQnLFxuICAgICAgICBwYXRoOiB0aGlzLmFjY2VwdE5vZGU8QVNULkxpdGVyYWw+KHJhd011c3RhY2hlLnBhdGgpLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICBoYXNoOiBiLmhhc2goKSxcbiAgICAgICAgZXNjYXBlZCxcbiAgICAgICAgbG9jXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCByYXdNdXN0YWNoZSBhcyBIYW5kbGViYXJzQVNULk11c3RhY2hlU3RhdGVtZW50ICYgeyBwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uIH0pO1xuICAgICAgbXVzdGFjaGUgPSBiLm11c3RhY2hlKHBhdGgsIHBhcmFtcywgaGFzaCwgIWVzY2FwZWQsIGxvYyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIC8vIFRhZyBoZWxwZXJzXG4gICAgICBjYXNlIFwidGFnTmFtZVwiOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnN0YXRlID0gXCJiZWZvcmVBdHRyaWJ1dGVOYW1lXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJlZm9yZUF0dHJpYnV0ZU5hbWVcIjpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImF0dHJpYnV0ZU5hbWVcIjpcbiAgICAgIGNhc2UgXCJhZnRlckF0dHJpYnV0ZU5hbWVcIjpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnN0YXRlID0gXCJiZWZvcmVBdHRyaWJ1dGVOYW1lXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWRcIjpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci5zdGF0ZSA9IFwiYmVmb3JlQXR0cmlidXRlTmFtZVwiO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXR0cmlidXRlIHZhbHVlc1xuICAgICAgY2FzZSBcImJlZm9yZUF0dHJpYnV0ZVZhbHVlXCI6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIuc3RhdGUgPSAnYXR0cmlidXRlVmFsdWVVbnF1b3RlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVkXCI6XG4gICAgICBjYXNlIFwiYXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZWRcIjpcbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVWYWx1ZVVucXVvdGVkXCI6XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gVE9ETzogT25seSBhcHBlbmQgY2hpbGQgd2hlbiB0aGUgdG9rZW5pemVyIHN0YXRlIG1ha2VzXG4gICAgICAvLyBzZW5zZSB0byBkbyBzbywgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBtdXN0YWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11c3RhY2hlO1xuICB9XG5cbiAgQ29udGVudFN0YXRlbWVudChjb250ZW50OiBIYW5kbGViYXJzQVNULkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgICB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0aGlzLnRva2VuaXplciwgY29udGVudCk7XG5cbiAgICB0aGlzLnRva2VuaXplci50b2tlbml6ZVBhcnQoY29udGVudC52YWx1ZSk7XG4gICAgdGhpcy50b2tlbml6ZXIuZmx1c2hEYXRhKCk7XG4gIH1cblxuICBDb21tZW50U3RhdGVtZW50KHJhd0NvbW1lbnQ6IEhhbmRsZWJhcnNBU1QuQ29tbWVudFN0YXRlbWVudCk6IE9wdGlvbjxBU1QuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50PiB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplci5zdGF0ZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd0NvbW1lbnQpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7IHZhbHVlLCBsb2MgfSA9IHJhd0NvbW1lbnQ7XG4gICAgbGV0IGNvbW1lbnQgPSBiLm11c3RhY2hlQ29tbWVudCh2YWx1ZSwgbG9jKTtcblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICBjYXNlIFwiYmVmb3JlQXR0cmlidXRlTmFtZVwiOlxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYmVmb3JlRGF0YSc6XG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVXNpbmcgYSBIYW5kbGViYXJzIGNvbW1lbnQgd2hlbiBpbiB0aGUgXFxgJHt0b2tlbml6ZXIuc3RhdGV9XFxgIHN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiJHtjb21tZW50LnZhbHVlfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX06JHtsb2Muc3RhcnQuY29sdW1ufWAsIHJhd0NvbW1lbnQubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIFBhcnRpYWxTdGF0ZW1lbnQocGFydGlhbDogSGFuZGxlYmFyc0FTVC5QYXJ0aWFsU3RhdGVtZW50KSB7XG4gICAgbGV0IHsgbG9jIH0gPSBwYXJ0aWFsO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBIYW5kbGViYXJzIHBhcnRpYWxzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKHBhcnRpYWwsIHBhcnRpYWwubmFtZSl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCwgcGFydGlhbC5sb2MpO1xuICB9XG5cbiAgUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWxCbG9jazogSGFuZGxlYmFyc0FTVC5QYXJ0aWFsQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyBsb2MgfSA9IHBhcnRpYWxCbG9jaztcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSGFuZGxlYmFycyBwYXJ0aWFsIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShwYXJ0aWFsQmxvY2ssIHBhcnRpYWxCbG9jay5uYW1lKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLCBwYXJ0aWFsQmxvY2subG9jKTtcbiAgfVxuXG4gIERlY29yYXRvcihkZWNvcmF0b3I6IEhhbmRsZWJhcnNBU1QuRGVjb3JhdG9yKSB7XG4gICAgbGV0IHsgbG9jIH0gPSBkZWNvcmF0b3I7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEhhbmRsZWJhcnMgZGVjb3JhdG9ycyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShkZWNvcmF0b3IsIGRlY29yYXRvci5wYXRoKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLCBkZWNvcmF0b3IubG9jKTtcbiAgfVxuXG4gIERlY29yYXRvckJsb2NrKGRlY29yYXRvckJsb2NrOiBIYW5kbGViYXJzQVNULkRlY29yYXRvckJsb2NrKSB7XG4gICAgbGV0IHsgbG9jIH0gPSBkZWNvcmF0b3JCbG9jaztcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSGFuZGxlYmFycyBkZWNvcmF0b3IgYmxvY2tzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKGRlY29yYXRvckJsb2NrLCBkZWNvcmF0b3JCbG9jay5wYXRoKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLCBkZWNvcmF0b3JCbG9jay5sb2MpO1xuICB9XG5cbiAgU3ViRXhwcmVzc2lvbihzZXhwcjogSGFuZGxlYmFyc0FTVC5TdWJFeHByZXNzaW9uKTogQVNULlN1YkV4cHJlc3Npb24ge1xuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHNleHByKTtcbiAgICByZXR1cm4gYi5zZXhwcihwYXRoLCBwYXJhbXMsIGhhc2gsIHNleHByLmxvYyk7XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uKTogQVNULlBhdGhFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBvcmlnaW5hbCwgbG9jIH0gPSBwYXRoO1xuICAgIGxldCBwYXJ0czogc3RyaW5nW107XG5cbiAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDIpID09PSAnLi8nKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVXNpbmcgXCIuL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lciBhbmQgdW5uZWNlc3Nhcnk6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCwgcGF0aC5sb2MpO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDMpID09PSAnLi4vJykge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYENoYW5naW5nIGNvbnRleHQgdXNpbmcgXCIuLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCwgcGF0aC5sb2MpO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHM6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCwgcGF0aC5sb2MpO1xuICAgICAgfVxuICAgICAgcGFydHMgPSBbIHBhdGgucGFydHMuam9pbignLycpIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzID0gcGF0aC5wYXJ0cztcbiAgICB9XG5cbiAgICBsZXQgdGhpc0hlYWQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgdG8gZml4IGEgYnVnIGluIHRoZSBIYW5kbGViYXJzIEFTVCB3aGVyZSB0aGUgcGF0aCBleHByZXNzaW9ucyBpblxuICAgIC8vIGB7e3RoaXMuZm9vfX1gIChhbmQgc2ltaWxhcmx5IGB7e2Zvby1iYXIgdGhpcy5mb28gbmFtZWQ9dGhpcy5mb299fWAgZXRjKVxuICAgIC8vIGFyZSBzaW1wbHkgdHVybmVkIGludG8gYHt7Zm9vfX1gLiBUaGUgZml4IGlzIHRvIHB1c2ggaXQgYmFjayBvbnRvIHRoZVxuICAgIC8vIHBhcnRzIGFycmF5IGFuZCBsZXQgdGhlIHJ1bnRpbWUgc2VlIHRoZSBkaWZmZXJlbmNlLiBIb3dldmVyLCB3ZSBjYW5ub3RcbiAgICAvLyBzaW1wbHkgdXNlIHRoZSBzdHJpbmcgYHRoaXNgIGFzIGl0IG1lYW5zIGxpdGVyYWxseSB0aGUgcHJvcGVydHkgY2FsbGVkXG4gICAgLy8gXCJ0aGlzXCIgaW4gdGhlIGN1cnJlbnQgY29udGV4dCAoaXQgY2FuIGJlIGV4cHJlc3NlZCBpbiB0aGUgc3ludGF4IGFzXG4gICAgLy8gYHt7W3RoaXNdfX1gLCB3aGVyZSB0aGUgc3F1YXJlIGJyYWNrZXQgYXJlIGdlbmVyYWxseSBmb3IgdGhpcyBraW5kIG9mXG4gICAgLy8gZXNjYXBpbmcg4oCTIHN1Y2ggYXMgYHt7Zm9vLltcImJhci5iYXpcIl19fWAgd291bGQgbWVhbiBsb29rdXAgYSBwcm9wZXJ0eVxuICAgIC8vIG5hbWVkIGxpdGVyYWxseSBcImJhci5iYXpcIiBvbiBgdGhpcy5mb29gKS4gQnkgY29udmVudGlvbiwgd2UgdXNlIGBudWxsYFxuICAgIC8vIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgaWYgKG9yaWdpbmFsLm1hdGNoKC9edGhpcyhcXC4uKyk/JC8pKSB7XG4gICAgICB0aGlzSGVhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgICBvcmlnaW5hbDogcGF0aC5vcmlnaW5hbCxcbiAgICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgICAgcGFydHMsXG4gICAgICBkYXRhOiBwYXRoLmRhdGEsXG4gICAgICBsb2M6IHBhdGgubG9jXG4gICAgfTtcbiAgfVxuXG4gIEhhc2goaGFzaDogSGFuZGxlYmFyc0FTVC5IYXNoKTogQVNULkhhc2gge1xuICAgIGxldCBwYWlyczogQVNULkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChiLnBhaXIocGFpci5rZXksIHRoaXMuYWNjZXB0Tm9kZTxBU1QuRXhwcmVzc2lvbj4ocGFpci52YWx1ZSksIHBhaXIubG9jKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuaGFzaChwYWlycywgaGFzaC5sb2MpO1xuICB9XG5cbiAgU3RyaW5nTGl0ZXJhbChzdHJpbmc6IEhhbmRsZWJhcnNBU1QuU3RyaW5nTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBzdHJpbmcudmFsdWUsIHN0cmluZy5sb2MpO1xuICB9XG5cbiAgQm9vbGVhbkxpdGVyYWwoYm9vbGVhbjogSGFuZGxlYmFyc0FTVC5Cb29sZWFuTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ0Jvb2xlYW5MaXRlcmFsJywgYm9vbGVhbi52YWx1ZSwgYm9vbGVhbi5sb2MpO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhhbmRsZWJhcnNBU1QuTnVtYmVyTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bWJlckxpdGVyYWwnLCBudW1iZXIudmFsdWUsIG51bWJlci5sb2MpO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSGFuZGxlYmFyc0FTVC5VbmRlZmluZWRMaXRlcmFsKSB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCwgdW5kZWYubG9jKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSGFuZGxlYmFyc0FTVC5OdWxsTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCwgbnVsLmxvYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMob3JpZ2luYWw6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgLy8gaWYgaXQgaXMgZW1wdHksIGp1c3QgcmV0dXJuIHRoZSBjb3VudCBvZiBuZXdsaW5lc1xuICAgIC8vIGluIG9yaWdpbmFsXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBvcmlnaW5hbC5zcGxpdChcIlxcblwiKS5sZW5ndGggLSAxLFxuICAgICAgY29sdW1uczogMFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVG9rZW5pemVyTG9jYXRpb24odG9rZW5pemVyOiBQYXJzZXJbJ3Rva2VuaXplciddLCBjb250ZW50OiBIYW5kbGViYXJzQVNULkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SGFuZGxlYmFyc0FTVC5TdHJpcEZsYWdzLCBzdHJpbmc+LCBjb250ZW50LnZhbHVlKTtcblxuICBsaW5lID0gbGluZSArIG9mZnNldHMubGluZXM7XG4gIGlmIChvZmZzZXRzLmxpbmVzKSB7XG4gICAgY29sdW1uID0gb2Zmc2V0cy5jb2x1bW5zO1xuICB9IGVsc2Uge1xuICAgIGNvbHVtbiA9IGNvbHVtbiArIG9mZnNldHMuY29sdW1ucztcbiAgfVxuXG4gIHRva2VuaXplci5saW5lID0gbGluZTtcbiAgdG9rZW5pemVyLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuZnVuY3Rpb24gYWNjZXB0Q2FsbE5vZGVzKGNvbXBpbGVyOiBIYW5kbGViYXJzTm9kZVZpc2l0b3JzLCBub2RlOiB7IHBhdGg6IEhhbmRsZWJhcnNBU1QuUGF0aEV4cHJlc3Npb24sIHBhcmFtczogSGFuZGxlYmFyc0FTVC5FeHByZXNzaW9uW10sIGhhc2g6IEhhbmRsZWJhcnNBU1QuSGFzaCB9KTogeyBwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb24sIHBhcmFtczogQVNULkV4cHJlc3Npb25bXSwgaGFzaDogQVNULkhhc2ggfSB7XG4gIGxldCBwYXRoID0gY29tcGlsZXIuUGF0aEV4cHJlc3Npb24obm9kZS5wYXRoKTtcblxuICBsZXQgcGFyYW1zID0gbm9kZS5wYXJhbXMgPyBub2RlLnBhcmFtcy5tYXAoZSA9PiBjb21waWxlci5hY2NlcHROb2RlPEFTVC5FeHByZXNzaW9uPihlKSkgOiBbXTtcbiAgbGV0IGhhc2ggPSBub2RlLmhhc2ggPyBjb21waWxlci5IYXNoKG5vZGUuaGFzaCkgOiBiLmhhc2goKTtcblxuICByZXR1cm4geyBwYXRoLCBwYXJhbXMsIGhhc2ggfTtcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudE1vZGlmaWVyKGVsZW1lbnQ6IFRhZzwnU3RhcnRUYWcnPiwgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyB9ID0gbXVzdGFjaGU7XG5cbiAgaWYgKGlzTGl0ZXJhbChwYXRoKSkge1xuICAgIGxldCBtb2RpZmllciA9IGB7eyR7cHJpbnRMaXRlcmFsKHBhdGgpfX19YDtcbiAgICBsZXQgdGFnID0gYDwke2VsZW1lbnQubmFtZX0gLi4uICR7bW9kaWZpZXJ9IC4uLmA7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEluICR7dGFnfSwgJHttb2RpZmllcn0gaXMgbm90IGEgdmFsaWQgbW9kaWZpZXI6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtsb2MgJiYgbG9jLnN0YXJ0LmxpbmV9LmAsIG11c3RhY2hlLmxvYyk7XG4gIH1cblxuICBsZXQgbW9kaWZpZXIgPSBiLmVsZW1lbnRNb2RpZmllcihwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyk7XG4gIGVsZW1lbnQubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KGF0dHJpYnV0ZTogQXR0cmlidXRlLCBwYXJ0OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgYXR0cmlidXRlLmlzRHluYW1pYyA9IHRydWU7XG4gIGF0dHJpYnV0ZS5wYXJ0cy5wdXNoKHBhcnQpO1xufVxuIl19